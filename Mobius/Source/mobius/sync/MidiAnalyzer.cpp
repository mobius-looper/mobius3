/**
 * Coordinates the MidiEventMonitor which detects start, stop and beats,
 * and MidiTempoMonitor which is doing clock tempo smoothing.
 *
 * Potential new parameters:
 *
 *     midiSmoothingWindow
 *        the size of the MidiTempoMonitor smoothing buffer
 *        defaults to 96 (4 beats)
 *
 *     midiWobbleThreshold
 *        the number of frames the unit length must change before we consider it
 *        defaults to 8
 *
 *     midiBpmTreshold
 *        the change in BPM that forces a unit length adjustment
 *        defaults to 1.0
 *
 *     midiDriftCheckpointBeats
 *        the number of beats that elapse between drift checkpoints
 *        defaults to 4
 *
 * This is the only analzer that needs to deal with significant jitter in the raw
 * sync pulses.  It operates in two modes: unlocked and locked.
 *
 * When unlocked, sync pulses are generated upon recipt of the raw MIDI beats
 * (every 24 clocks).  The tempo is monitored and smoothed to a degree and a pending
 * unit length is calculated.  This unit length is allowed to fluctuate while unlocked.
 * The longer you allow the analyzer to run unlocked the better the tempo guess.
 *
 * When locked, the most recent unit length is held constant (until broken) and sync
 * pulses are generated by "playing" a virtual loop.  Each pulse will be exactly the length
 * of the unit.  Locking happens whenever a synchronized recording is ended for the first time.
 *
 * The lock may be broken in two ways: through the detection of a SIGNIFICANT change in tempo
 * and by the reset of all previously recorded loops that were following this sync source.
 *
 * After unlocking, the unit length is again allowed to fluctuate and track user initiated
 * tempo changes.
 */

#include <JuceHeader.h>

#include "../../util/Trace.h"
#include "../../midi/MidiByte.h"

// so we can have a pseudo-loop for tracking progress
// migth want to put that in a wrapper to keep this focused?
#include "../../model/Session.h"
#include "../../model/SessionHelper.h"
#include "../../model/SyncState.h"
#include "../../model/PriorityState.h"

#include "SyncMaster.h"
#include "MidiAnalyzer.h"

//////////////////////////////////////////////////////////////////////
//
// Configuration
//
//////////////////////////////////////////////////////////////////////

/**
 * Sanity checks on tempo/unit length.
 * See wild ranges occasionally after emergency resync, should be preventing
 * those.
 */
static const int MidiMinTempo = 30;
static const int MidiMaxTempo = 300;

MidiAnalyzer::MidiAnalyzer()
{
}

MidiAnalyzer::~MidiAnalyzer()
{
}

void MidiAnalyzer::initialize(SyncMaster* sm, MidiManager* mm)
{
    syncMaster = sm;
    midiManager = mm;
    mm->addRealtimeListener(this);
}

void MidiAnalyzer::setSampleRate(int rate)
{
    sampleRate = rate;
    tempoMonitor.setSampleRate(rate);
}

void MidiAnalyzer::shutdown()
{
    shuttingDown = true;
    midiManager->removeRealtimeListener(this);
}

//////////////////////////////////////////////////////////////////////
//
// Stoppage
//
//////////////////////////////////////////////////////////////////////

/**
 * Expected to be called periodically to check whather clocks are still
 * being received.
 *
 * When this happens there are two options for the tempo display:
 * 
 * 1) Reset it so that doesn't display anything and rebuilds the tempo
 *    from scratch when the clocks restart
 *
 * 2) Leave the last tempo in place, under the assumption that the user will
 *    most likely continue or restart using the same tempo.
 *
 * What the display says about tempo isn't that important, but it is more
 * interesting to preserve the previous unit length.  If we had just spent
 * minutes smoothing out a unit length and some tracks started following that,
 * that shouldn't be immediately abandoned when clocks start up again unless
 * the tempo deviation is severe.  Due to constant jitter, starting over with
 * a new unit length could be a few samples off the previous and would result in
 * an unnecessary adjustment.
 *
 * Once the unit length is set it STAYS THERE until we're in a position to
 * reliably calculate a new one.
 */
void MidiAnalyzer::checkClocks()
{
    tempoMonitor.checkStop();
}

/**
 * When this happens all tracks will be quiet and empty and we can reset
 * any drift monitoring that may have been going on.
 * Not normally necessary, but after debugging the clocks can get way out
 * of sync and it will perpetually whine about it.
 */
void MidiAnalyzer::globalReset()
{
    Trace(2, "MidiAnalyzer: Unlocking on globalReset");
    elapsedBeats = tempoMonitor.getElapsedClocks() / 24;
    locked = false;
}

//////////////////////////////////////////////////////////////////////
//
// State
//
//////////////////////////////////////////////////////////////////////

/**
 * This fills in everything except the normalized
 * beat/bar/loop counts which SyncMaster/BarTender will add
 */
void MidiAnalyzer::refreshState(SyncState* state)
{
    state->midiReceiving = isReceiving();
    state->midiStarted = isRunning();
    state->midiTempo = getTempo();
    state->midiNativeBeat = eventMonitor.beat;
    state->midiSongPosition = eventMonitor.songPosition;
    
    state->midiUnitLength = unitLength;
    state->midiPlayHead = unitPlayHead;
}

//////////////////////////////////////////////////////////////////////
//
// SyncAnalyzer Interface
//
//////////////////////////////////////////////////////////////////////

SyncAnalyzerResult* MidiAnalyzer::getResult()
{
    return &result;
}

bool MidiAnalyzer::isLocked()
{
    return locked;
}

/**
 * True if we have received a MIDI start or continue message.
 */
bool MidiAnalyzer::isRunning()
{
    return eventMonitor.started;
}

int MidiAnalyzer::getNativeBeat()
{
    return eventMonitor.beat;
}

int MidiAnalyzer::getElapsedBeats()
{
    return elapsedBeats;
}

/**
 * Once the unit length is locked, display the locked tempo so the UI doesn't flicker.
 * Might want to also have a way to display the fluctuating raw tempo.
 */
float MidiAnalyzer::getTempo()
{
    if (unitLength > 0)
      return tempoMonitor.unitLengthToTempo(unitLength);
    else
      return tempoMonitor.getAverageTempo();
}

int MidiAnalyzer::getUnitLength()
{
    return unitLength;
}

/**
 * MIDI does drift a different way, and needs a different interface.
 */
int MidiAnalyzer::getDrift()
{
    return 0;
}

int MidiAnalyzer::getPlayHead()
{
    return unitPlayHead;
}

//////////////////////////////////////////////////////////////////////
//
// Extended Public Interface
//
//////////////////////////////////////////////////////////////////////

bool MidiAnalyzer::isReceiving()
{
    return tempoMonitor.isReceiving();
}

int MidiAnalyzer::getSongPosition()
{
    return eventMonitor.songPosition;
}

//////////////////////////////////////////////////////////////////////
//
// MidiManager::RealtimeListener
//
//////////////////////////////////////////////////////////////////////

/**
 * Given a MIDI Realtime message received from a MIDI device, add the
 * interesting ones to the input queue.
 *
 * We'll get SystemCommon messages as well as Realtime messages which
 * we need for SongPosition.  Everything else ignore.
 */
void MidiAnalyzer::midiRealtime(const juce::MidiMessage& msg, juce::String& source)
{
    (void)source;

    if (shuttingDown) return;

    // do TempoMonitor first since EventMonitor may need to
    // reset it's stream time if a start point is detected
    tempoMonitor.consume(msg);
    
    bool startPoint = eventMonitor.consume(msg);
    if (startPoint) {
        tempoMonitor.orient();
    }
}

//////////////////////////////////////////////////////////////////////
//
// Analysis
//
//////////////////////////////////////////////////////////////////////

/**
 * Consume any queued events at the beginning of an audio block
 * and prepare the SyncAnalyzerResult
 */
void MidiAnalyzer::analyze(int blockFrames)
{
    result.reset();

    // detect start and stop
    if (playing != eventMonitor.started) {
        if (eventMonitor.started) {
            result.started = true;
            playing = true;
            unitPlayHead = 0;
            elapsedBeats = 0;
            streamTime = 0;
            lastMonitorBeat = 0;
            driftCheckCounter = 0;

            if (!eventMonitor.continued) {
                Trace(2, "MidiAnalyzer: Start");
            }
            else {
                Trace(2, "MidiAnalyzer: Continue %d", eventMonitor.songPosition);
                // the clock of the native song position we're starting from
                int songPositionClocks = eventMonitor.songPosition * 6;
                // the native beat number this is
                elapsedBeats = songPositionClocks / 24;
            }

            // hmm, could force an unlock at this point, try to keep
            // using the last one
        }
        else {
            Trace(2, "MidiAnalyzer: Stop");
            result.stopped = true;
            playing = false;
            // do not necessarily need to unlock here, since it is quite likely
            // it will just start up again at the same tempo
        }

        // Start is considered a beat pulse, so don't detect another
        // one until the next full beat comes in
        lastMonitorBeat = eventMonitor.elapsedBeats;
    }
    else if (lastMonitorBeat != eventMonitor.elapsedBeats) {
        // a native beat came in
        // if this isn't 1 away, it means we missed a beat
        // can't happen in practice unless the tempo is unusably fast
        // or you're suspending in the debugger
        if (lastMonitorBeat + 1 != eventMonitor.elapsedBeats)
          Trace(1, "MidiAnalyzer: Missed beats");

        ponderUnitLength();

        lastMonitorBeat = eventMonitor.elapsedBeats;
    }

    advance(blockFrames);
}

/**
 * Here on each full beat from the MIDI input.
 * This is where all the head scratching lives...
 * 
 * First go through a few ignore tests for tempo/units that are out of
 * wack, which can happen during debugging with some threads suspended
 * while the MIDI thread continues.
 *
 * Next test two thresholds to determine whether moving the unit length is
 * allowed.
 *
 * If the BPM change is significant we are unlocked and generate a beat pulse.
 *
 * Sigh, even with a relatively high smoothing window of 128 clock samples, this still
 * results in a unit bounce almost every beat.  It's very minor:
 *
 * MidiAnalyzer: Adjusting unit length from 32000 to 31998 tempo 90.008209
 * MidiAnalyzer: Adjusting unit length from 31998 to 32000 tempo 89.999329
 * MidiAnalyzer: Adjusting unit length from 32000 to 31998 tempo 90.007492
 * MidiAnalyzer: Adjusting unit length from 31998 to 32000 tempo 90.001404
 * MidiAnalyzer: Adjusting unit length from 32000 to 31998 tempo 90.003922
 * MidiAnalyzer: Adjusting unit length from 31998 to 32000 tempo 90.002602
 *
 * To further reduce noise, don't adjust unless the unit length changes more
 * than some number of samples from it's current value.  Needs to be tunable...
 * Should further suppress the ocassional outlier that jumps way out of wack
 * then comes back down.  It needs to be sustained in one direction before we adjust.
 *
 * Tempo anomolies that result in a resync of the tempo monitor, or wildly out
 * of range tempos are common when you've been stopped in the debugger while
 * MIDI clocks keep coming in.  Suppress those, but they're unexpected normally
 * so trace an error.
 */
void MidiAnalyzer::ponderUnitLength()
{
    int newUnitLength = tempoMonitor.getAverageUnitLength();
    // convert length to a clipped tempo to make it easier to sanity check
    int newClippedTempo = (int)(tempoMonitor.getAverageTempo());

    if (newUnitLength == 0) {
        // common after an emergency resync during debugging but not
        // on the first lock
        if (unitLength == 0)
          Trace(1, "MidiAnalyzer: Unable to do first unit lock");
    }
    else if (newClippedTempo < MidiMinTempo || newClippedTempo > MidiMaxTempo) {
        // something went haywire in TempoMonitor, if we're not filling this is unusual
        Trace(1, "MidiAnalyzer: Ignoring unusual unit length %d", newUnitLength);
    }
    else if (tempoMonitor.isFilling() && unitLength != 0) {
        // common after a cold start
        // common after emergency resync after debugging, continue with the
        // old length until the buffer fills
        //Trace(2, "MidiAnalyzer: Waiting for tempo smoother to fill");
    }
    else if (newUnitLength == unitLength) {
        //Trace(2, "MidiAnalyzer: Unit length remains %d", unitLength);
    }
    else {
        // cut down on noise by suppressing minor wobbles
        // play around with this, 4 may be enough, but user initiated tempo changes are rare
        // and the initial guess is usually pretty close
        int wobbleThreshold = 8;
        int change = abs(unitLength - newUnitLength);
        if (change <= wobbleThreshold) {
            // this is likely to be noisy, remove it after verified that it works
            //Trace(2, "MidiAnalyzer: Suppressing unit adjust within wobble range %d to %d",
            //unitLength, newUnitLength);
        }
        else {
            // derive the new tempo from the unit length
            // if the tempo changes by one full BPM it relocks, regardless of followers
            // followers if any become disconnected and drift free
            float newTempo = tempoMonitor.unitLengthToTempo(newUnitLength);
            int bpmDelta = abs((int)(tempo - newTempo));
            if (bpmDelta >= 1) {
                // suppress this trace if we're on the first beat starting from nothing
                if (unitLength > 0) {
                    if (locked)
                      Trace(2, "MidiAnalyzer: Breaking lock");
                    char buf[256];
                    sprintf(buf, "MidiAnalyzer: Jumping to new tempo from %f to %f",
                            tempo, newTempo);
                    Trace(2, buf);
                }
                locked = false;
            }

            // two situations here: unlocked or locked early during the dead zone
            if (!locked || unitLength == 0) {
                char buf[256];
                if (unitLength > 0) {
                    sprintf(buf, "MidiAnalyzer: Adjusting unit length from %d to %d tempo %f",
                            unitLength, newUnitLength, newTempo);
                }
                else {
                    // include a little extra trace the first time we identify a unit
                    sprintf(buf, "MidiAnalyzer: Starting unit length %d clock length %f running average %f tempo %f",
                            newUnitLength,
                            tempoMonitor.getAverageClockLength(), tempoMonitor.getAverageClock(),
                            newTempo);
                    // on the initial lock, we're expected to go ahead and define
                    // a unit even if the smoothing window isn't full, it will be less accurate
                    // but may be adjusted over time if the recording goes on long enough
                    if (tempoMonitor.isFilling())
                      Trace(2, "MidiAnalyzer: Deriving unit during fill period, potentially unstable");
                    
                    // initial advance should always be around 5.3 blocks per clock,
                    // 24 clocks per beat, in the first beat 256 block size
                    // MidiAnalyzer: Start
                    // MidiAnalyzer: Initial advance 32640
                    // MidiAnalyzer: Starting unit length 32580 clock length 1357.459050 running average 0.028280 tempo 88.397797
                    //Trace(2, "MidiAnalyzer: Initial advance %d", unitPlayHead);
                }
                Trace(2, buf);

                unitLength = newUnitLength;
                tempo = newTempo;
            }
        }
    }

    // advance doesn't bump the beat counter if we're unlocked so need to do
    // it here
    if (!locked || unitLength == 0) {
        // generate a beat pulse in this block
        result.beatDetected = true;
                
        // start the virtual play head over from the beginning
        unitPlayHead = 0;

        elapsedBeats = eventMonitor.elapsedBeats;
        streamTime = elapsedBeats * unitLength;
    }
}

/**
 * Advance the pseudo loop and keep track of beat bar boundaries.
 *
 * If we're unlocked, then advance the loop to record the passage of
 * stream time, but don't generate any beats since those will be handled
 * by ponderUnitLength on each raw beat.
 */
void MidiAnalyzer::advance(int frames)
{
    if (playing) {
        unitPlayHead += frames;

        if (locked) {
            if (unitLength == 0) {
                // still waiting for the native first beat after starting
            }
            else if (unitPlayHead >= unitLength) {
                // a unit has transpired
                int over = unitPlayHead - unitLength;
                if (over > frames || over < 0) {
                    // this has happened after suspending in the debugger and
                    // the threads start advancing in unusual ways
                    // or maybe you're just bad at this
                    Trace(1, "MidiAnalyzer: The universe is wrong and/or you suck at math");
                    // don't let bizarre buffer offsets escape and confuse the TimeSlicer
                    over = 0;
                }
                
                int blockOffset = frames - over;
                unitPlayHead = over;

                elapsedBeats++;
            
                result.beatDetected = true;
                result.blockOffset = blockOffset;
            }

            // now that we don't have bar/loop detection down here, need a good point
            // to check for drift, every 4 beats seems fine
    
            if (result.beatDetected) {

                driftCheckCounter++;
                // should be configurable!
                if (driftCheckCounter >= 4) {
                    driftCheckCounter = 0;
            
                    // perfection is when our elapsed best counter matches the
                    // the MIDI thread's elapsed clock counter
                    // it will often be 1 clock lower or higher due to normal jitter
                    // but once it becomes higher it is a significant tempo drift
                    // and should be corrected
                    int elapsedMidiClocks = tempoMonitor.getElapsedClocks();
                    int expectedClocks = elapsedBeats * 24;

                    // drift is negative when the audio stream is behind
                    int drift = expectedClocks - elapsedMidiClocks;

                    if (abs(drift) > 1) {
                        Trace(2, "MidiAnalyzer: Clock drift %d", drift);

                        // todo: the magic of drift correction
                    }

                    // this was an experiment that didn't work
                    // all TempoMonitor stream time does is bring it up to "now" time
                    // which is more or less the same as audio stream time
                    // it detects audio block jitter but that isn't interresting for correction
                    // watching clock counts works well enough, can abandon this
#if 0        
                    int midiStreamTime = tempoMonitor.getStreamTime();
                    // do this before including the advance in this block
                    Trace(2, "MidiAnalyzer: Stream drift %d", streamTime - midiStreamTime);
#endif        
                }
            }
        }
    }
    
    streamTime += frames;
}

/**
 * Called by SyncMaster when a track needs to complete a synchronized
 * recording and must finalize a stable unit length.
 */
void MidiAnalyzer::lock()
{
    if (!locked) {
        Trace(2, "MidiAnalyzer: Locking unit length %d playHead %d",
              unitLength, unitPlayHead);

        if (unitLength == 0) {
            // we're in the "first beat dead zone" and will wait until the
            // first beat comes in nbefore locking
            Trace(2, "MidiAnalyzer: Dead zone unit lock pending");
        }
        else {
            // the virtual play head has been advancing since the last
            // native beat without wrapping, wherever it is now becomes the
            // basis for the first normalized beat
            if (unitPlayHead > unitLength) {
                Trace(1, "MidiAnalyzer: Unexpected play head during lock %d unit length %d",
                      unitPlayHead, unitLength);
                // not uncommon for this to be larger than unit length if we're very close to the end?
                unitPlayHead -= unitLength;
            }
            else if (unitPlayHead == unitLength) {
                // I think this can happen if the stars align and the recording
                // ends exactly on the native beat
                Trace(2, "MidiAnalyzer: Returning unitPlayHead to zero for normalized beat");
                unitPlayHead = 0;
            }
        }

        locked =  true;
    }
}

/**
 * Used after an anomolous track recording has been made to force the unit
 * length to match the track rather than the other way around.  If it is
 * within the same BPM tolerance that is used for jitter, it is allowed.
 */
bool MidiAnalyzer::forceUnitLength(int proposed)
{
    bool allowed = false;
    
    float effectiveTempo = tempoMonitor.unitLengthToTempo(proposed);
    int clippedTempo = (int)effectiveTempo;

    if (clippedTempo < MidiMinTempo || clippedTempo > MidiMaxTempo) {
        Trace(1, "MidiAnalyzer: Ignoring force of unusual unit length %d", proposed);
    }
    else if (unitLength == 0) {
        // apparently never been used or locked, surprising
        Trace(1, "MidiAnalyzer: Forceing unit length where there was none before, really?");
        allowed = true;
    }
    else {
        // do we care if it was unlocked?
        int bpmDelta = abs((int)(tempo - effectiveTempo));
        if (bpmDelta >= 1) {
            Trace(2, "MidiAnalyzer::forceUnitLength Proposal was out of range %d",
                  proposed);
        }
        else {
            allowed = true;
        }
    }

    if (allowed) {
        unitLength = proposed;
        tempo = effectiveTempo;
        if (unitPlayHead >= unitLength)
          unitPlayHead = unitPlayHead % unitLength;
        locked = true;
    }
    
    return allowed;
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

