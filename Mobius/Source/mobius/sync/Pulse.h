/**
 * Model for an abstract "pulse" generated by a synchronization source.
 * Synchronization events from various sources are converted into a Pulse
 * and managed by the Pulsator.
 *
 * Pulses contain various information about where the pulse exists in time.
 * The blockFrame offset into the audio block is the most important.
 *
 * The other fields have additional information that followers may
 * wish to respond to but are not required.
 *
 * todo: reconsider whether to even bother with these, intelligent
 * following of external song position or transport location is enormously
 * complex.  For all practical purposes the followers shouldn't really
 * care about whether the transport starts and stops, but Pulsator does
 * so it can decide whether it is worth monitoring drift.
 *
 */

#pragma once

#include "../../model/SyncConstants.h"
#include "SyncEvent.h"

class Pulse
{
  public:

    Pulse() {}
    ~Pulse() {}

    // where the pulse came from
    SyncSource source = SyncSourceNone;

    // the pulse granularity
    SyncUnit unit = SyncUnitBeat;
    
    // system time this pulse was detected, mostly for debugging
    int millisecond = 0;

    // the sample/frame offset into the current audio block where this
    // pulse logically happened
    int blockFrame = 0;

    // special flag for sync events that happen just after the end of the block
    bool pending = false;

    // this pulse also represents the host transport or MIDI clocks
    // moving to their start point
    bool start = false;

    // this pulse also represents the external transport stopping
    // not really a pulse but conveyed as one
    bool stop = false;

    // !! much more work to do here for MIDI Continue and song position
#if 0
    // this pulse also represents the movement of the external transport
    // to a random location
    bool mcontinue = false;

    // when continue is true, the logical pulse in the external sequence
    // we're continuing from, aka the "song position pointer"
    int continuePulse = 0;
#endif

    SyncEvent event;

    void reset(SyncSource s, int msec) {
        source = s;
        millisecond = msec;
        blockFrame = 0;
        pending = false;
        //beat = 0;
        //bar = 0;
        start = false;
        stop = false;
        //mcontinue = false;
        //continuePulse = 0;
        event.reset();
    }

    void reset() {
        reset(SyncSourceNone, 0);
    }
    
};

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
