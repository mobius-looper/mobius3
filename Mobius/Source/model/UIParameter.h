/*
 * The base model for UIParameter definitions.
 *
 * Subclasses of UIParameter are generated by the "mobu" utility and
 * placed in the UIParameterClasses.cpp/h files.
 *
 */

#pragma once

// for juce::var only
#include <JuceHeader.h>

#include "SystemConstant.h"

// externs for the generated object pointers are now in here
#include "UIParameterClasses.h"

//////////////////////////////////////////////////////////////////////
// Enumerations
//////////////////////////////////////////////////////////////////////

/**
 * The type of the parameter.
 * The canonical type names found in the generator source files are:
 *
 *   int, bool, enum, string
 *
 * Type names must follow those names with capitalization.
 */
typedef enum {

	TypeInt,
	TypeBool,
	TypeEnum,
	TypeString,
    TypeStructure

} UIParameterType;

/**
 * Parameter scope.
 * Canonical names: global, preset, setup, track
 *
 * The corresponding model classes are:
 *
 * MobiusConfig, Preset, Setup, SetupTrack
 *
 * MobiusConfig is the only one whose name differs from the canonical name.
 * Should we have a model for mapping these?
 */
typedef enum {

    ScopeNone,
    ScopeGlobal,
    ScopePreset,
    ScopeSetup,
    ScopeTrack,
    ScopeUI

} UIParameterScope;

//////////////////////////////////////////////////////////////////////
// Class
//////////////////////////////////////////////////////////////////////

/**
 * Continue using const char* for strings so we don't have to
 * rip up the model editors yet, but move to juce::String eventually
 * Especially for the arrays.
 *
 * SystemConstant defines name and displayName
 */
class UIParameter : public SystemConstant
{
  public:

	UIParameter();
	~UIParameter();

    /**
     * For configuration parameters, indidicates which structdure this
     * parameter lives in.  Global=MobiusConfig, Preset=Preset, etc.
     */
    UIParameterScope scope = ScopeGlobal;

    /**
     * The value type.
     */
	UIParameterType type = TypeInt;
    
    /**
     * True if it supports multiple values.
     */
    bool multi = false;

    /**
     * For TypeEnum, the  set of allowed values.
     */
    const char** values = nullptr;

    /**
     * For TypeEnum, the set of alternate display names.
     */
	const char** valueLabels = nullptr;

    /**
     * For TypeInt, the lowest allowed value.
     */
    int low = 0;

    /**
     * For TypeInt, the highest allowed value.
     * If the dynamic flag is set, the high value must be calculated
     * at runtime.
     */
    int high = 0;

    /**
     * for TypeInt, the base value to display rather than the low value.
     * This is only used for ports where the low value starts from zero but
     * we want to display them starting from 1.
     */
    int displayBase = 0;

    /**
     * For TypeInt, a few parameters may have a default value other
     * than zer.  Typically this will be the upper end of a range
     * or the center.
     */
    int defaultValue = 0;

    /**
     * Indiciates the high value must be calculated at runtime.
     */
    bool dynamic = false;
    
    /**
     * Indicates that the value should be displayed as a positive
     * or negative integer with zero at the center of the low/high range.
     */
    bool zeroCenter = false;

    /**
     * Indicates that this can be highlighted in the UI as a sweepable control.
     * These are the most common parameters used in bindings and can be
     * separated from other parameters to make them easier to find.
     * Explore other presentation categories like "advanced".
     */
    bool control = false;

    /**
     * Indicates that this parameter exists only at runtime and will not
     * be saved in a configuration file.  It can still be used in bindings
     * but will be omitted from configuration file generators.
     */
    bool transient = false;

    /**
     * Indiciates that this parameter may use juce::var for value access.
     * Since we're redesigning this model just for the UI, this can
     * eventually be the default and we can remove ExValue
     */
    bool juceValues = false;

    /**
     * Indicates that this parameter cannot be bound to MIDI or host parameters
     * so keep it out of the operation selection UI.
     */
    bool noBinding;

    /**
     * Indiciates that this parameter is visible for bindings, but not found
     * in configuration files so no get/set code will be generated.
     * They can only be used at runtime, and are set with UIActions
     * and read with MobiusState or Query.
     * Used for various control parameters related to speed and pitch.
     * update: This appears to be unused and the same as "transient"
     */
    //bool noConfig;
    
    //////////////////////////////////////////////////////////////////////
    // 
    // Runtime Options
    //
    // These are from the core Parameter model and are not used in the UI.
    // We don't need them if we keep the models separate, which I'm leaning toward.
    // Unfortunately they're used in the generated code so keep them in until
    // we get rid of generated UIParameter definition objects.
    //
    //////////////////////////////////////////////////////////////////////

    /**
     * Indiciates that the value of current value of this parameter is to be retained
     * after a track is Reset.
     */
    bool resetRetain;

    /**
     * Setting this parameter results in scheduling a function.
     * Used for the Pitch related parameters.
     */
    bool scheduled;

    /**
     * In a few cases the names were changed to be more consistent
     * or obvious or because I liked them better.  In order to correlate
     * the new parameter definitions with the old ones, this would
     * be the name of the old Parameter.
     *
     * update: this was used when we generated code for UIParameter definitions
     * it may not be necessary any more, except for correlating core parameters.
     */
    const char* coreName = nullptr;
    
    //////////////////////////////////////////////////////////////////////
    //
    // Value Access Functions
    //
    // At least one set of ExValue or juce::var functions must be implemented
    // in the subclass. Starting with ExValue being required and juce::var
    // being optional, but need to switch the UI to use juce::var
    //
    // The values are always represented as ordinal integers except for
    // type=string and type=structure.
    //
    // type=structure string values are efffectively an enumeration whose
    // set of allowed values is known and must be queried.
    // 
    //////////////////////////////////////////////////////////////////////

    virtual void getValue(void* /* object */, class ExValue* /* value */) = 0;
    virtual void setValue(void* /* object */, class ExValue* /* value */) = 0;

    // shouldn't this just return a juce::var by value?
    // implementations are stubbed and only used if juceValues is set
    virtual void getValue(void* /* object */, juce::var& /* value */) {
    }
    
    virtual void setValue(void* /* object */, juce::var& /* value */) {
    }

    //////////////////////////////////////////////////////////////////////
    //
    // Enumeration Utilities
    //
    //////////////////////////////////////////////////////////////////////
    
    /**
     * For type=enum, convert a symbolic value into an ordinal value by
     * locating the given value within the allowedValues set.
     *
     * This currently only supports internal names, not display names.
     * Do we have a reason to support display names?
     *
     * Original model getEnun would trace a warning if the value was
     * not in the set of allowed values and returned zero.  This now
     * does not trace and returns -1.
     */
    int getEnumOrdinal(const char* value);

    /**
     * For type=enum, convert an ordinal value into the symbolic value
     * defined by the values array.
     */
    const char* getEnumName(int ordinal);

    /**
     * For type=enum, convert an ordinal value into the symbolic value
     * defined by the valueLabels array.
     */
    const char* getEnumLabel(int ordinal);

    //////////////////////////////////////////////////////////////////////
    //
    // Model Queries
    //
    // For parameters with type='structure' or options='dynamic' some
    // characteristics of the parameter cannot be statically defined and
    // must be calculated at runtime.  These functions provide a way to do that
    // until the Query model is fleshed out.
    //
    // Currently it is assumed that the calculation can be satisfied using
    // only the model contained within MobiusConfig.  Eventually some of
    // these will shift to UIConfig or another object at which point Query
    // must be used in a larger context.
    //
    //////////////////////////////////////////////////////////////////////
    
    /**
     * Calculate the maximum ordinal value of a dynamic or structure parameter.
     */
    int getDynamicHigh(class MobiusConfig* container);

    /**
     * For type=structure, calculate the set of structure names.
     * This is in effect the symbolic values of a dynamic enumeration.
     * If this becomes necessary for types other than type=structure
     * change the name.
     * 
     * The result is returned as a StringList and must be deleted.
     */
    class StringList* getStructureNames(class MobiusConfig* container);

    /**
     * For type=structure convert a symbolic structure name into an ordinal
     * within the value as that would be returned by getDynamicValues
     */
    int getStructureOrdinal(class MobiusConfig* container, const char* name);

    /**
     * For type=structure convert an ordinal into a symbolic name.
     * Note that the string returned will be found within the container
     * model and will become invalid if the container is deleted.
     * It should be considered temporary and copied if it needs to live
     * for an indefinite time.
     */
    const char* getStructureName(class MobiusConfig* container, int ordinal);

    //////////////////////////////////////////////////////////////////////
    //
    // Global Parameter Registry
    //
    //////////////////////////////////////////////////////////////////////

    static std::vector<UIParameter*> Instances;
    static void trace();
	static UIParameter* find(const char* name);
	static UIParameter* findDisplay(const char* name);

  private:

    class Structure* getStructureList(class MobiusConfig* container);
    
};

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
