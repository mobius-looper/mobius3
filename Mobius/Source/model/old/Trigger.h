/**
 * A collection of static objects that define the types of things
 * that can cause something to happen.  They are part of both
 * the Action and Binding models, but factored out because they
 * need to be used are used at various levels that don't need to
 * understand where they came from.
 *
 * They self initialize during static initialization and will
 * self destruct.
 *
 * The trigger type is normally only used for these things:
 *
 *     - building optimized jump tables to locate the action
 *       associated with each trigger
 *
 *     - to infer the default "sustainability" of a trigger
 *       when detecting down/up transitions or long-presses
 *
 * Other than those uses, the system should not care what
 * caused an action to happen.
 *
 * In the Action model, every Trigger must have an associated
 * "id" which uniquely defines the triggers of that type.  For
 * example a TriggerKey would have an id that is a key code,
 * TriggerMidi would have an id that combinind the channel,
 * message type, and key number.
 *
 */

#pragma once

#include <vector>

#include "SystemConstant.h"

//////////////////////////////////////////////////////////////////////
//
// Trigger
//
//////////////////////////////////////////////////////////////////////

/**
 * Triggers are the "who" of a binding.
 * They define where the trigger came from which in turn may
 * imply things about the way the action should be processed.
 */
class Trigger : public SystemConstant {
  public:

    static std::vector<Trigger*> Instances;
    static Trigger* find(const char* name);
    static bool isMidi(Trigger* t);

    Trigger(const char* name, const char* display);
    
};

// these have historically been global constants
// think about moving them inside the Trigger class

/**
 * A computer keyboard key
 */
extern Trigger* TriggerKey;

/**
 * A MIDI event: note, program change, control change, pitch wheel
 */
extern Trigger* TriggerMidi;

/**
 * A parameter binding from a plugin host
 */
extern Trigger* TriggerHost;

/**
 * A message sent through the Open Sound Protocol
 */
extern Trigger* TriggerOsc;

/**
 * An event that ocurred in the user interface such
 * as a button click, or a menu item selection.
 */
extern Trigger* TriggerUI;

//
// These are like sub-types of TriggerMidi that represent
// the different types of MIDI events.  They are not used
// in the Action model, only as a convenience for the binding UI
//
// todo: try to get rid of these
//

extern Trigger* TriggerNote;
extern Trigger* TriggerProgram;
extern Trigger* TriggerControl;
extern Trigger* TriggerPitch;

//
// These represent triggers for internally generated
// actions, not in direct response to the user
//

/**
 * A trigger caused by a script
 */
extern Trigger* TriggerScript;

/**
 * Trigger caused by the maintenance thread
 *
 * todo: this is only used in one place, when processing
 * the results of a completed KernelEvent.  There is
 * overlap with this and TriggerEvent.  I don't think
 * we need to over-specify these, a single TriggerSystem
 * should be enough?
 */
extern Trigger* TriggerThread;

/**
 * Trigger caused by the completion of a track Event.
 */
extern Trigger* TriggerEvent;

/**
 * Trigger generated by system code that doesn't fit in
 * the previous three categories.
 * Currently unused.
 */
extern Trigger* TriggerUnknown;

//////////////////////////////////////////////////////////////////////
//
// Trigger Mode
//
//////////////////////////////////////////////////////////////////////

/**
 * Defines the behavior of the trigger over time.
 * 
 * Triggers can behave in several ways, the most common are
 * as momentary buttons and as continuous controls.
 *
 * Some trigger constants imply their mode, TriggerNote
 * for example can be assumed to behave like a momentary button.
 * Others like TriggerOsc and TriggerUI are more generic.  They
 * may have several behaviors.  
 *
 * If a Binding is created with an ambiguous Trigger, a TriggerMode
 * may also be specified.  If not then TriggerTypeOnce is assumed.
 *
 */
class TriggerMode : public SystemConstant {
  public:

    static std::vector<TriggerMode*> Instances;
    static TriggerMode* find(const char* name);

    TriggerMode(const char* name, const char* display);
};

// the trigger happens a single time
extern TriggerMode* TriggerModeOnce;

// the trigger has both on/pressed and up/released transitions
extern TriggerMode* TriggerModeMomentary;

// the trigger sweeps through a range of values
extern TriggerMode* TriggerModeContinuous;

// the trigger is momentary, but sustains for an indefinite period of time
extern TriggerMode* TriggerModeToggle;

// the trigger is continues but sweeps through two ranges of values (never used)
extern TriggerMode* TriggerModeXY;

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
