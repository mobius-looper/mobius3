/**
 * A library of functions that may be directly called from MSl scripts
 * rather than using Symbols and UIActions.
 *
 * Unlike action functions, these support complex argument lists
 * and return values.
 *
 * Supervisor resolves named references to these and creates an MslExternal
 * that identifies the function with an id within the ScriptExternalId enumeration.
 */
 
#include <JuceHeader.h>

#include "../util/Trace.h"
#include "../util/Util.h"
#include "../midi/MidiByte.h"

#include "../model/UIConfig.h"

#include "../Supervisor.h"
#include "../mobius/MobiusKernel.h"

#include "MslContext.h"
#include "MslExternal.h"
#include "MslArgumentParser.h"

#include "ScriptExternals.h"

/**
 * Struct defining the association of a external name and the numeric id.
 * Used when resolving name references from a script.
 * Order is not significant.
 */
ScriptExternalDefinition ScriptExternalDefinitions[] = {

    {"MidiOut", FuncMidiOut, ScriptContextNone, true},
    {"GetMidiDeviceId", FuncGetMidiDeviceId, ScriptContextNone, true},
    {"InstallUIElement", FuncInstallUIElement, ScriptContextShell, true},

    // core variables, formerly implemented by ScriptInternalVariable

    {"blockFrames", VarBlockFrames, ScriptContextKernel, false},
    {"sampleRate", VarSampleRate, ScriptContextKernel, false},
    {"sampleFrames", VarSampleFrames, ScriptContextKernel, false},
    {"loopCount", VarLoopCount, ScriptContextKernel, false},
    {"loopNumber", VarLoopNumber, ScriptContextKernel, false},
    {"loopFrames", VarLoopFrames, ScriptContextKernel, false},
    {"loopFrame", VarLoopFrame, ScriptContextKernel, false},
    {"cycleCount", VarCycleCount, ScriptContextKernel, false},
    {"cycleNumber", VarCycleNumber, ScriptContextKernel, false},
    {"cycleFrames", VarCycleFrames, ScriptContextKernel, false},
    {"cycleFrame", VarCycleFrame, ScriptContextKernel, false},
    {"subcycleCount", VarSubcycleCount, ScriptContextKernel, false},
    {"subcycleNumber", VarSubcycleNumber, ScriptContextKernel, false},
    {"subcycleFrames", VarSubcycleFrames, ScriptContextKernel, false},
    {"subcycleFrame", VarSubcycleFrame, ScriptContextKernel, false},
    {"modeName", VarModeName, ScriptContextKernel, false},
    // old scripts heavily use this name
    {"mode", VarModeName, ScriptContextKernel, false},
    {"isRecording", VarIsRecording, ScriptContextKernel, false},
    {"inOverdub", VarInOverdub, ScriptContextKernel, false},
    {"inHalfspeed", VarInHalfspeed, ScriptContextKernel, false},
    {"inReverse", VarInReverse, ScriptContextKernel, false},
    {"inMute", VarInMute, ScriptContextKernel, false},
    {"inPause", VarInPause, ScriptContextKernel, false},
    {"inRealign", VarInRealign, ScriptContextKernel, false},
    {"inReturn", VarInReturn, ScriptContextKernel, false},
    {"playbackRate", VarPlaybackRate, ScriptContextKernel, false},
    {"trackCount", VarTrackCount, ScriptContextKernel, false},
    {"audioTrackCount", VarAudioTrackCount, ScriptContextKernel, false},
    {"midiTrackCount", VarMidiTrackCount, ScriptContextKernel, false},
    {"activeAudioTrack", VarActiveAudioTrack, ScriptContextKernel, false},
    {"focusedTrack", VarFocusedTrack, ScriptContextKernel, false},
    {"scopeTrack", VarScopeTrack, ScriptContextKernel, false},
    {"globalMute", VarGlobalMute, ScriptContextKernel, false},
    {"trackSyncMaster", VarTrackSyncMaster, ScriptContextKernel, false},
    {"transportMaster", VarTransportMaster, ScriptContextKernel, false},
    {"syncTempo", VarSyncTempo, ScriptContextKernel, false},
    {"syncRawBeat", VarSyncRawBeat, ScriptContextKernel, false},
    {"syncBeat", VarSyncBeat, ScriptContextKernel, false},
    {"syncBar", VarSyncBar, ScriptContextKernel, false},

    {nullptr, ExtNone, ScriptContextNone, false}

};
 
/**
 * Map a function name into an internal id.
 * todo: if this starts getting large, use a HashMap
 */
ScriptExternalDefinition* ScriptExternals::find(juce::String name)
{
    ScriptExternalDefinition* def = nullptr;

    for (int i = 0 ; ScriptExternalDefinitions[i].name != nullptr ; i++) {
        if (strcmp(ScriptExternalDefinitions[i].name, name.toUTF8()) == 0) {
            def = &(ScriptExternalDefinitions[i]);
            break;
        }
    }
    return def;
}

/**
 * Eventually called by Supervisor in response to an action
 * generated by the script session.  The context here may
 * either be Supervisor or MobiusKernel since we don't force
 * a side.
 */
bool ScriptExternals::doAction(MslContext* c, MslAction* action)
{
    bool success = false;
    ScriptExternalType type = (ScriptExternalType)(action->external->type);
    
    if (type == ExtTypeFunction) {

        // prevent assertion failure if the id is out of range
        int intId = action->external->id;
        if (intId >= 0 && intId < (int)ExtMax) {
            ScriptExternalId id = (ScriptExternalId)intId;

            switch (id) {
            
                case FuncMidiOut:
                    success = MidiOut(c, action);
                    break;
                case FuncGetMidiDeviceId:
                    success = GetMidiDeviceId(c, action);
                    break;
                case FuncInstallUIElement:
                    success = InstallUIElement(c, action);
                    break;

                default:
                    Trace(1, "ScriptExternals: Unhandled external id %d", id);
                    break;
            }
        }
        else {
            Trace(1, "ScriptExternals: Invalid external id %d", intId);
        }
    }
    else if (type == ExtTypeVariable) {
        // no settable varialbes yet
        Trace(1, "ScriptExternals: Assignment of external variables not implemented");
    }
    else {
        // shouldn't have gotten this far
        // parameters are handled elsewhere
        Trace(1, "ScriptExternals: Assignment of external variables not implemented");
    }
    
    return success;
}

//////////////////////////////////////////////////////////////////////
//
// Functions
//
//////////////////////////////////////////////////////////////////////

/**
 * Assemble a MIDI event from action arguments.
 * A very similar dance is done down in mobius/core/functions/Midi.cpp
 * except that it uses ExValueList rather than an MslValue list.
 * Consider finding a way to share.
 *
 * The old format was this, best to keep it the same;
 *
 * MidiOut <status> <channel> <value> <velocity>
 * status: noteon noteoff control program 
 * channel: 0-15
 * value: 0-127
 * velocity: 0-127
 *
 * I'd like to make some of these optional but it's hard without using
 * keyword arguments.
 *
 * To those I would like to add deviceId, but this will conflict with
 * velocity if you stick it on the end.  If we put it at the beginning e
 * can treat it like an alternative function signature.  If the first argument
 * is an integer, then it must be a device id.  To use symbolic device names
 * they must call GetMidiDevice(name)
 */
bool ScriptExternals::assembleMidiMessage(MslContext* c, MslAction* action, juce::MidiMessage& msg,
                                          bool* returnSync,
                                          int *returnDeviceId)
{
    bool failed = false;
    int deviceId = -1;
	int status = 0;
	int channel = 0;
	int number = 0;
	int velocity = 0;
    bool isSync = false;

    //
    // In retrospect, it would be a lot easier for externals to deal with
    // an Array of arguments rather than a linked list.  Easier to access
    // and reason about.
    //
    
    MslValue* arg = action->arguments;
    if (arg == nullptr) {
        Trace(1, "MidiOut: No function arguments");
        failed = true;
    }
    else if (arg->type == MslValue::Int) {
        deviceId = arg->getInt();
        arg = arg->next;
    }
    else if (arg->isNull()) {
        // most likely an initialized variable that was supposed
        // to have a deviceId, really anything other than a String is considered
        // the deviceId
        Trace(1, "MidiOut: Device id argument was null");
        arg = arg->next;
    }
    else if (arg->type == MslValue::String &&
             arg->next != nullptr && arg->next->type == MslValue::String) {
        // two strings in a row, first one must be the device name
        const char* devName = arg->getString();
        deviceId = getMidiDeviceId(c, devName);
        if (deviceId == -1) {
            Trace(1, "MidiOut: Invalid device name %s", devName);
            // could treat this as a failure, or just ignore and and use the default
        }
        arg = arg->next;
    }

    if (!failed) {
        if (arg == nullptr) {
            Trace(1, "MidiOut: Missing message type");
            failed = true;
        }
        else {
            const char* type = arg->getString();
            if (StringEqualNoCase(type, "note") ||
                StringEqualNoCase(type, "noteon")) {
                status = MS_NOTEON;
                velocity = 127;
            }
            else if (StringEqualNoCase(type, "noteoff")) {
                status = MS_NOTEOFF;
            }
            else if (StringEqualNoCase(type, "control") ||
                     StringEqualNoCase(type, "cc")) {
                status = MS_CONTROL;
            }
            else if (StringEqualNoCase(type, "program") ||
                     StringEqualNoCase(type, "pgm")) {
                status = MS_PROGRAM;
            }
            // these are occasionally necessary
            else if (StringEqualNoCase(type, "start")) {
                status = MS_START;
                isSync = true;
            }
            else if (StringEqualNoCase(type, "continue")) {
                status = MS_CONTINUE;
                isSync = true;
            }
            else if (StringEqualNoCase(type, "stop")) {
                status = MS_STOP;
                isSync = true;
            }
            else if (StringEqualNoCase(type, "clock")) {
                status = MS_CLOCK;
                isSync = true;
            }
            // these are almost never used, and I probably have parsing wrong anyway
            else if (StringEqualNoCase(type, "poly")) {
                status = MS_POLYPRESSURE;
            }
            else if (StringEqualNoCase(type, "touch")) {
                status = MS_TOUCH;
            }
            else if (StringEqualNoCase(type, "bend")) {
                status = MS_BEND;
            }
            else {
                Trace(1, "MidiOut: Invalid status %s\n", type);
                failed = true;
            }
            arg = arg->next;
        }
    }

    // second argument is the channel
    if (!failed && !isSync) {
        if (arg == nullptr) {
            Trace(1, "MidiOut: Missing message channel");
            failed = true;
        }
        else {
            channel = arg->getInt();
            arg = arg->next;
        }
    }

    // third argument is the note/program/control number
    if (!failed && !isSync) {
        if (arg == nullptr) {
            Trace(1, "MisiOut: Missing message number");
            failed = true;
        }
        else {
            number = arg->getInt();
            arg = arg->next;
        }
    }
    
    // final argument is the optional velocity
    if (!failed && !isSync) {
        if (arg != nullptr) {
            velocity = arg->getInt();
            arg = arg->next;
        }
    }
    
    if (!failed && arg != nullptr) {
        // not really a problem, but they probably did something wrong
        Trace(1, "MidiOut: Ignoring extra arguments");
    }
    
    if (!failed) {

        int juceChannel = channel + 1;
        
        switch (status) {
            
            case MS_NOTEON:
                msg = juce::MidiMessage::noteOn(juceChannel, number, (juce::uint8)velocity);
                break;
                
            case MS_NOTEOFF:
                msg = juce::MidiMessage::noteOff(juceChannel, number, (juce::uint8)velocity);
                break;

            case MS_PROGRAM:
                msg = juce::MidiMessage::programChange(juceChannel, number);
                break;

            case MS_CONTROL:
                msg = juce::MidiMessage::controllerEvent(juceChannel, number, (juce::uint8)velocity);
                break;

            case MS_CLOCK:
            case MS_START:
            case MS_STOP:
            case MS_CONTINUE: {
                msg = juce::MidiMessage(status, 0, 0);
            }

            default: {
                // punt and hope the 3 byte constructor is smart enough to figure out how
                // many bytes the status actually needs
                // todo: test this
                int byte1 = status | channel;
                msg = juce::MidiMessage(byte1, number, (juce::uint8)velocity);
            }
        }

        if (returnSync != nullptr)
          *returnSync = isSync;

        if (returnDeviceId != nullptr)
          *returnDeviceId = deviceId;
    }

    return !failed;
}


/**
 * Send a MIDI event.
 *
 * The script will most often be an event script running in the kernel.
 * This raises an interesting issue about what to do if we are in the
 * UI instead and running as a plugin.  If there are no direct MIDI
 * devices open, then MIDI is sent through Juce during audio block processing.
 * There isn't a mechanism for the UI to send the event down to the Kernel
 * to include on the next block.  There should be but it isn't likely to happen.
 * This does argue for this to be a Kernel context function to force a thread
 * transition if it happens.
 */
bool ScriptExternals::MidiOut(MslContext* c, MslAction* action)
{
    juce::MidiMessage msg;
    int deviceId = -1;
    bool isSync = false;

    bool success = assembleMidiMessage(c, action, msg, &isSync, &deviceId);

    if (success) {
    
        if (c->mslGetContextId() == MslContextShell) {
            Supervisor* s = static_cast<Supervisor*>(c);
            if (deviceId == -1) {
                // todo: check if we can even do this and warn
                if (isSync)
                  s->midiSendSync(msg);
                else
                  s->midiExport(msg);
            }
            else {
                s->midiSend(msg, deviceId);
            }
        }
        else {
            MobiusKernel* kernel = static_cast<MobiusKernel*>(c);
            if (deviceId == -1) {
                if (isSync)
                  kernel->midiSendSync(msg);
                else
                  kernel->midiSendExport(msg);
            }
            else {
                kernel->midiSend(msg, deviceId);
            }
        }
    }
    
    return success;
}

/**
 * Get the internal numeric device identifier for a device name
 */
bool ScriptExternals::GetMidiDeviceId(MslContext* c, MslAction* action)
{
    bool success = false;

    MslValue* arg = action->arguments;
    if (arg == nullptr) {
        Trace(1, "GetMidiDeviceId: No arguments");
    }
    else if (arg->type != MslValue::String) {
        Trace(1, "GetMidiDeviceId: Name argument not a string");
    }
    else {
        int deviceId = getMidiDeviceId(c, arg->getString());
        if (deviceId == -1) {
            Trace(1, "GetMidiDeviceId: Invalid device name %s", arg->getString());
        }
        else {
            success = true;
        }

        // whether succesfull or not return -1 in case they want to deal with that?
        action->result.setInt(deviceId);
    }
    
    return success;
}

/**
 * Get the internal numeric device identifier for a device name
 */
int ScriptExternals::getMidiDeviceId(MslContext* c, const char* name)
{
    int deviceId = -1;

    if (c->mslGetContextId() == MslContextShell) {
        Supervisor* s = static_cast<Supervisor*>(c);
        deviceId = s->getMidiOutputDeviceId(name);
    }
    else {
        MobiusKernel* kernel = static_cast<MobiusKernel*>(c);
        deviceId = kernel->getMidiOutputDeviceId(name);
    }

    return deviceId;
}

//////////////////////////////////////////////////////////////////////
//
// UI Configuration
//
//////////////////////////////////////////////////////////////////////

/**
 * Expecting three arguments:
 *    name
 *    variable
 *    visualizer
 *    property list
 *
 * The property list consists of alternating pairs of keyword symbols and values
 *
 * e.g: InstallUIElement("something" "myvar" "Light" :onColor "red" :offColor "black")
 *
 * Since this is specific to variable visualizers might want to call this
 *
 * InstallVariableUIElement
 *
 */
bool ScriptExternals::InstallUIElement(MslContext* c, MslAction* action)
{
    bool success = false;

    if (c->mslGetContextId() != MslContextShell) {
        Trace(1, "InstallUIElement must be called in shell context");
    }
    else {
        Supervisor* s = static_cast<Supervisor*>(c);

        MslArgumentParser p(action);

        const char* name = p.nextString();
        const char* variable = p.nextString();
        const char* visualizer = p.nextString();

        if (name == nullptr)
          Trace(1, "InstallUIElement: Missing element name");
        else if (variable == nullptr)
          Trace(1, "InstallUIElement: Missing variable");
        else if (visualizer == nullptr)
          Trace(1, "InstallUIElement: Missing visualizer");
        else {

            UIConfig* config = s->getUIConfig();
            juce::String jname(name);
            UIElementDefinition* def = config->findDefinition(jname);
            bool created = false;
            if (def == nullptr) {
                def = new UIElementDefinition();
                def->name = jname;
                created = true;
            }
            else {
                // here we could skip this if it was already defined but until
                // we have an editor it is more convenient to let the script
                // rebuild it on every load
            }

            // todo: could do some validation on this
            def->visualizer = visualizer;
            def->properties.set("monitor", variable);

            bool error = false;
            MslArgumentParser::Keyarg* keyarg = p.nextKeyarg();
            while (!error && keyarg != nullptr) {
                error = keyarg->error;
                if (!error) {
                    def->properties.set(juce::String(keyarg->name), juce::String(keyarg->value->getString()));
                    keyarg = p.nextKeyarg();
                }
            }

            if (error) {
                Trace(1, "InstallUIElement: Malformed keyword list");
                if (created)
                  delete def;
            }
            else {
                if (created)
                  config->definitions.add(def);

                // note well
                // there is an initialalization order dependency here
                // if you call updateUIConfig now, it will propagate the changes to the
                // UI components.  The new ones that can monitor MSL variables will attempt
                // to locate Symbols for those variables, But at this moment, we are using
                // in the static initialization period of MSL script loading and those
                // variables may not be defined and exported yet, you get a log error and
                // the UIElement won't have a symbol and will do nothing
                // since uiconfig.xml is updated on shutdown we don't really need to save
                // it here.  If that stops happening then we'll need some sort of deferred
                // update with propagation after the scripts have been loaded
                //s->updateUIConfig();
                
                success = true;
            }
        }
    }
    
    return success;
}

bool ScriptExternals::buildMap(MslValue* plist, juce::HashMap<juce::String,juce::String>& map)
{
    bool success = true;
    
    while (plist != nullptr) {
        MslValue* name = plist;
        MslValue* value = plist->next;
        if (value == nullptr) {
            Trace(1, "ScriptExternals: Malformed property list");
            success = false;
            break;
        }
        else {
            map.set(juce::String(name->getString()), juce::String(value->getString()));
            plist = value->next;
        }
    }
    return success;
}

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

