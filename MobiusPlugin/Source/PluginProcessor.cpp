/**
 * Juce AudioProcessor implementation for the Mobius plugin.
 * 
 * This file was generated by Projucer.
 * I've made minimal modifications to connect it to Supervisor.
 * It does not appear to be regenerated unless you change the project type.
 * Changes to plugin metadata in Projucer are stored here:
 *
 *    ../JuceLibraryCode/JucePluginDefines.h
 *
 * That's where the various "JucePlugin_Name" etc. symbols are defined.
 *
 * Current Projucer config allows {2,2},{4,4} for the audio channel configuration
 * and 16 MIDI channels.  In the Juce plugin host, I see 4 audio pins, and 1 MIDI pin.
 *
 * c:/dev/jucetest/UI has been added as a header file search path so we can
 * use relative includes like the main body of code.
 *
 * For reference, these are some AudioProcessor methods that were not overridden
 * in the generated code but may be intersting to explore:
 *
 * There seem to be two categories of these: those the host calls to get information
 * about the plugin, and those the plugin calls on itself to get information about the host.
 *
 * getAlternateDisplayNames
 * memoryWarningReceived - lol, sure I want that
 * processBlockBypassed
 *   I seem to remember we did something here, I guess we're not supposed to be generating
 *   any sound, but we may need to advance sync time and continue to do UI refreshes?
 *
 * ..all Bus related stuff...
 *
 * supportsDoublePrecisionProcessing
 *    I doubt this would ever be interesting, and would require yuge engine modification
 *
 * getPlayHead
 *   we're ABSOLUTELY going to want this for sync, seems to be something we pull in
 *   rather than push out
 *   docs say "this can ONLY be called from your processBlock method"
 * 
 * getTotalNumInputChannels
 *    I think this is information for block processing we're supposed to use
 *
 * getSampleRate
 * getBlockSize
 *    valid only in processBlock, I guess we forward MobiusContainer methods
 *    to this rather than following what was passed in prepareToPlay?
 *
 * getLatencySamples
 *    this is used to tell the host how may latency WE add to processing
 *    without any sub-plugins like pitch shift there won't be any
 *
 * getTailLengthSamples
 *    could be interesting
 *
 * getCallbackLock
 *    "This returns a critical section that will automatically be locked while the host
 *     is calling processBlock.  Use it from your UI or other threads to lock access to
 *     variables that are used by the process callback, but obviously be careful not to
 *     keep it locked for too long, because that could cause stuttering playback. If
 *     you need to do something that'll take a long time and need the processing to stop
 *     while it happens, use the suspendProcessing() method instead.
 *
 *   Not entirely sure what this does, I think it keeps processBlock from being entered
 *   for a brief period of time, probably not necessary with KernelCommunicator architecture.
 *
 * suspendProcessing
 *   "Enables and disables the processing callback.
 *   If you need to do something time-consuming on a thread and would like to make sure the audio
 *   processing callback doesn't happen until you've finished, use this to disable the
 *   callback and re-enable it again afterwards."
 *
 *   Might be useful for project loading?
 *
 *   "If the host tries to make an audio callback while processing is suspended, the processor will
 *    return an empty buffer, but won't block the audio thread like it would do if you use the
 *    getCallbackLock() critical section to synchronise access.
 *   Any code that calls processBlock() should call isSuspended() before doing so, and if the
 *   processor is suspended, it should avoid the call and emit silence or whatever is appropriate.
 *
 * virtual reset()
 *   override to be told when to reset any playing voices
 *   hmm, could be a GlobalReset hook?
 *
 * getActiveEditor
 *   not sure where I would use this, it says "should only call from the message thread"
 *
 * updateHostDisplay
 *   "The processor can call this when something (apart from a parameter value) has changed.
 *    It sends a hint to the host that something like the program, number of parameters,
 *    etc, has changed, and that it should update itself.
 *
 * ...all stuff related to Parameters...
 *
 * numChannelsChanged
 *    tell the host to rethink our channels, useful if you want to support dynamic
 *    port configuration
 *
 * addListener
 *   this is an override add a listener to receive notifications when something
 *   inside the plugin changes, I guess the host could call this, not sure why
 *
 * setPlayHead
 *   "tells the processor to use this playhead object"
 *   will want this
 *
 * setPlayConfigDetails
 * setRateAndBufferSizeDetails
 *    seems to be something the processor calls to tell the host it has desires
 *
 * updateTrackProperties
 *    "informs processor that track properties such as name or colour has changed"
 *    so what, we're supposed to care if they want it green?
 *
 */

#include "util/Trace.h"

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================

// notes on PreferredChannelConfigurations
// this has been defined in Projucer so #ifndef conditionals in the generated
// code will be false.  The bus configuration seems to be handled deep in
// the library code in juce_audio_plugin_client_VST3 which takes the string from Projecer
// and uses it as an array initializer
// {4,4} results in 4 IO pins, but it's unclear what the AudioChannelSet is
// there is a "discrete" AudioChannelSet which is probably what we want here, or at least
// that's how old Mobius did it in VST2.  In VST3, it may make sense to define each
// stereo pair as seperate busses of sterro channels so they can be given names like
// Port1, Port2, etc. that the host can display, but will need to do a lot of experimentation
// to see which hosts actually do anything with that
//
// There doesn't seem to be a way to change the BusesProperties after construction,
// or at least the tutorial says you're not supposed to and that the host can request different
// layouts that we need to approve or not
// The Projecer string accepts multiple array initializers, so some comments indicate that
// certain hosts may not work well with large IO channels so we could have both {2,2}{16,16}
// as options.  To make this be dynamically configurable, you take the string out of Projecer
// and then use the AudioProcessor constructor to pass a BussesProperties object.  To allow that
// to be configured in mobius.xml we would have to read the config file during the construction
// of everything, which I think we're allowed to do but RootLocator will not have been run yet
// so it would be a somewhat complicated set of explorations that have to happen during construction.
// for now, relying on Projecer to give the plugin a reasonably large set of pins, 16 should be good
// for most except that guy that wanted 32 tracks which would be 64 freaking pins.
// Definitely don't want that many in the usual case.


// This is the default constructor generated by Projucer
//MobiusPluginAudioProcessor::MobiusPluginAudioProcessor()
//#ifndef JucePlugin_PreferredChannelConfigurations
//     : AudioProcessor (BusesProperties()
//                     #if ! JucePlugin_IsMidiEffect
//                      #if ! JucePlugin_IsSynth
//                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
//                      #endif
//                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
//                     #endif
//                       )
//#endif

// this is mine that tries to achieve {2,2} without PreferredChannelConfigurations
// ugh, the usual folderol with references, can't call a method on the object before
// it has finished initialization?
// or maybe I had did something before, whatever, this compiles
// so having done all this shit, AudioProcessor seems to have a way to dynamically
// add/remove buses, which we could try inside the constructor rather than
// having to use BusesProperties as a definitional object

juce::AudioProcessor::BusesProperties MobiusPluginAudioProcessor::ConstructorBuses;

juce::AudioProcessor::BusesProperties& MobiusPluginAudioProcessor::getConstructorBuses()
{
    ConstructorBuses = BusesProperties()
        .withInput("Input", juce::AudioChannelSet::stereo(), true)
        .withOutput("Output", juce::AudioChannelSet::stereo(), true)
        .withInput("AuxIn", juce::AudioChannelSet::stereo(), true)
        .withOutput("AuxOut", juce::AudioChannelSet::stereo(), true)
        .withInput("AuxIn2", juce::AudioChannelSet::stereo(), true)
        .withOutput("AuxOut2", juce::AudioChannelSet::stereo(), true);
        
    return ConstructorBuses;
}

// attempt with BusesProperties in the constructor
MobiusPluginAudioProcessor::MobiusPluginAudioProcessor()
    : AudioProcessor (getConstructorBuses())
{
    // set this early in case we're not connecting Supervisor and just want
    // to watch plugin methods get called
    TraceDebugLevel = 2;

    // I'm really starting to hate this RAII shit, at least for massive
    // things like Supervisor.  It's going to build out EVERYTHING before
    // we've even know what the host is going to want.  If it's just
    // scanning plugins, we've done all that UI configuration for nothing
    // RootLocator::whereAmI();

    // the environment we're in is conceptually like the MainComponent
    // constructor when running standalone
    // Supervisor is a static member and we start it
    supervisorStarted = supervisor.start();

    // test this
    //juce::AudioProcessor::BusesProperties props = getConstructorBuses();
    //dumpBuses(props);

    Trace(2, "Plugin busses at construction\n");
    dumpPluginBuses();
}

MobiusPluginAudioProcessor::~MobiusPluginAudioProcessor()
{
    // unlike MainComponent we don't shutdownAudio here
    // so it is unclear when exactly we can be sure processBlock will no
    // longer be called

    supervisor.shutdown();
}

void MobiusPluginAudioProcessor::reset()
{
    Trace(2, "MobiusPluginAudioProcessor::reset\n");
}


void MobiusPluginAudioProcessor::dumpBuses(juce::AudioProcessor::BusesProperties& props)
{
    Trace(2, "BusesProperties:\n");
    dumpBusProperties("Input", props.inputLayouts);
    dumpBusProperties("Output", props.outputLayouts);
}

void MobiusPluginAudioProcessor::dumpBusProperties(juce::String  type, juce::Array<juce::AudioProcessor::BusProperties>& array)
{
    Trace(2, "  %s: %d properties\n", type.toUTF8(), array.size());
    for (int i = 0 ; i < array.size() ; i++) {
        juce::AudioProcessor::BusProperties props = array[i];
        dumpBusProperties(props);
    }
}

void MobiusPluginAudioProcessor::dumpBusProperties(juce::AudioProcessor::BusProperties& props)
{
    juce::String name = props.busName;
    if (props.isActivatedByDefault) name += " default";

    Trace(2, "    BusProperties %s\n", name.toUTF8());
    dumpAudioChannelSet(props.defaultLayout);
}

/**
 * Dump the bus state of the plugin after initialization.
 */
void MobiusPluginAudioProcessor::dumpPluginBuses()
{
    Trace(2, "AudioProcessor Busses:\n");
    
    Trace(2, "  Input buses: %d\n", getBusCount(true));
    for (int i = 0 ; i < getBusCount(true) ; i++) {
        juce::AudioProcessor::Bus* bus = getBus(true, i);
        dumpBus(bus);
    }

    Trace(2, "  Output buses: %d\n", getBusCount(false));
    for (int i = 0 ; i < getBusCount(true) ; i++) {
        juce::AudioProcessor::Bus* bus = getBus(false, i);
        dumpBus(bus);
    }
}

void MobiusPluginAudioProcessor::dumpBus(juce::AudioProcessor::Bus* bus)
{
    Trace(2, "    Bus: %s\n", bus->getName().toUTF8());
    Trace(2, "      isMain: %s\n", getTruth(bus->isMain()));
    Trace(2, "      isEnabled: %s\n", getTruth(bus->isEnabled()));
    Trace(2, "      isEnabledByDefault: %s\n", getTruth(bus->isEnabledByDefault()));
    Trace(2, "      channels: %d\n", bus->getNumberOfChannels());
    Trace(2, "      maxChannels: %d\n", bus->getMaxSupportedChannels());
    Trace(2, "      CurrentLayout\n");
    dumpAudioChannelSet(bus->getCurrentLayout());
}

void MobiusPluginAudioProcessor::dumpAudioChannelSet(const juce::AudioChannelSet& set)
{
    Trace(2, "        Channel set:\n");
    Trace(2, "          channels %d\n", set.size());
    Trace(2, "          disabled: %s\n", getTruth(set.isDisabled()));
    Trace(2, "          discrete: %s\n", getTruth(set.isDiscreteLayout()));
    Trace(2, "          speaker arrangement: %s\n", set.getSpeakerArrangementAsString().toUTF8());
    Trace(2, "          description: %s\n", set.getDescription().toUTF8());
    Trace(2, "          ambisonic order: %d\n", set.getAmbisonicOrder());

    juce::String types;
    for (int i = 0 ; i < set.size() ; i++) {
        juce::AudioChannelSet::ChannelType type = set.getTypeOfChannel(i);
        if (type == juce::AudioChannelSet::ChannelType::left)
          types += "left ";
        else if (type == juce::AudioChannelSet::ChannelType::right)
          types += "right ";
        else
          types += juce::String(type) + " ";
    }
    Trace(2, "          channel types: %s\n", types.toUTF8());
}

const char* MobiusPluginAudioProcessor::getTruth(bool b)
{
    return (b ? "true" : "false");
}
    
//==============================================================================

//
// I'm leaving the generated code mostly in place and using
// the JucePlugin symbols though we could dispense with that
// and just hard code them
//

const juce::String MobiusPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

/**
 * Should always be true
 */
bool MobiusPluginAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
  return true;
#else
  return false;
#endif
}

/**
 * Should always be true
 */
bool MobiusPluginAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

/**
 * Should always be false. This makes some hosts think
 * that we won't need any audio pins.
 */
bool MobiusPluginAudioProcessor::isMidiEffect() const
{
#if JucePlugin_IsMidiEffect
    return true;
#else
    return false;
#endif
}

/**
 * This could be interesting, if you've got a loop going
 * and you suspend the plugin, we could do a GlobalReset
 * and add a fade tail.
 */
double MobiusPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

/**
 * I think in olden times, we let Presets be our "programs".
 * This was never very useful.  The closest thing for Mobius might
 * be Projects, but that's a very heavy weight thing to be casually
 * flipping around in a host menu.
 */
int MobiusPluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MobiusPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

/**
 * Set all you want, we follow our own path.
 */
void MobiusPluginAudioProcessor::setCurrentProgram (int index)
{
    (void)index;
}

/**
 * Here Juce just returned an empty string with {}
 * Rather than Projects or Setups I suppose we could a few useful
 * configurations of Setups with some minimal content that is a subset
 * of the saved Projects.
 */
const juce::String MobiusPluginAudioProcessor::getProgramName (int index)
{
    (void)index;
    // return {};
    return juce::String("Standard");
}

void MobiusPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    (void)index;
    (void)newName;
}

//==============================================================================

/**
 * This is where it starts gettting interesting.
 * Forward audio block processing to Supervisor.
 */
void MobiusPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    supervisor.prepareToPlayPlugin(sampleRate, samplesPerBlock);
}

void MobiusPluginAudioProcessor::releaseResources()
{
    supervisor.releaseResourcesPlugin();
}

/**
 * This we will want to eventually deal with.
 * I have Projucer configured with the simplfied bus layouts {2,2},{4,4}
 * so this should be bypassed.
 */
#ifndef JucePlugin_PreferredChannelConfigurations
bool MobiusPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    // This is the place where you check if the layout is supported.
    // In this template code we only support mono or stereo.
    // Some plugin hosts, such as certain GarageBand versions, will only
    // load plugins that support stereo bus layouts.

    // jsl - modified this to only allow stereo
    //if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()
    //&& layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
    //return false;
    // todo: now that we have an aux bus, I guess we should be checking those too?
    
    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
      return false;
    
    // This checks if the input layout matches the output layout
   #if ! JucePlugin_IsSynth
    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())
        return false;
   #endif

    return true;
  #endif
}
#endif

/**
 * I moved the boilerplate code over to Supervisor
 * as a starting point.
 */
void MobiusPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    if (!pluginBusesTraced) {
        Trace(2, "Plugin busses at first block\n");
        dumpPluginBuses();
        pluginBusesTraced = true;
    }
    
    supervisor.processBlockPlugin(buffer, midiMessages);
}

//==============================================================================

/**
 * Always have, always will.
 */
bool MobiusPluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

/**
 * Generated code always created a new one of these
 * and I assume it gets deleted automatically when the host
 * window closes.  Pass along Supervisor since it will always need it.
 */
juce::AudioProcessorEditor* MobiusPluginAudioProcessor::createEditor()
{
    bool genericEditor = false;

    if (genericEditor)
      return new juce::GenericAudioProcessorEditor (*this);
    else
      return new MobiusPluginAudioProcessorEditor (*this, &supervisor);
}

//==============================================================================

/**
 * I'd like to support this someday, but I'm not sure I ever did before.
 * What would be useful here?  I guess a snapshot of the exported UIParameters
 * that were bound, but don't really need this since everything is in mobius.xml.
 */
void MobiusPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    (void)destData;
}

void MobiusPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    (void)data;
    (void)sizeInBytes;
}

//==============================================================================

// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MobiusPluginAudioProcessor();
}
