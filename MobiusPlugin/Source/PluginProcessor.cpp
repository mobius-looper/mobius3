/**
 * Juce AudioProcessor implementation for the Mobius plugin.
 * 
 * This file was generated by Projucer.
 * I've made minimal modifications to connect it to Supervisor.
 * It does not appear to be regenerated unless you change the project type.
 * Changes to plugin metadata in Projucer are stored here:
 *
 *    ../JuceLibraryCode/JucePluginDefines.h
 *
 * That's where the various "JucePlugin_Name" etc. symbols are defined.
 *
 * Current Projucer config allows {2,2},{4,4} for the audio channel configuration
 * and 16 MIDI channels.  In the Juce plugin host, I see 4 audio pins, and 1 MIDI pin.
 *
 * c:/dev/jucetest/UI has been added as a header file search path so we can
 * use relative includes like the main body of code.
 *
 * For reference, these are some AudioProcessor methods that were not overridden
 * in the generated code but may be intersting to explore:
 *
 * There seem to be two categories of these: those the host calls to get information
 * about the plugin, and those the plugin calls on itself to get information about the host.
 *
 * getAlternateDisplayNames
 * memoryWarningReceived - lol, sure I want that
 * processBlockBypassed
 *   I seem to remember we did something here, I guess we're not supposed to be generating
 *   any sound, but we may need to advance sync time and continue to do UI refreshes?
 *
 * ..all Bus related stuff...
 *
 * supportsDoublePrecisionProcessing
 *    I doubt this would ever be interesting, and would require yuge engine modification
 *
 * getPlayHead
 *   we're ABSOLUTELY going to want this for sync, seems to be something we pull in
 *   rather than push out
 *   docs say "this can ONLY be called from your processBlock method"
 * 
 * getTotalNumInputChannels
 *    I think this is information for block processing we're supposed to use
 *
 * getSampleRate
 * getBlockSize
 *    valid only in processBlock, I guess we forward MobiusContainer methods
 *    to this rather than following what was passed in prepareToPlay?
 *
 * getLatencySamples
 *    this is used to tell the host how may latency WE add to processing
 *    without any sub-plugins like pitch shift there won't be any
 *
 * getTailLengthSamples
 *    could be interesting
 *
 * getCallbackLock
 *    "This returns a critical section that will automatically be locked while the host
 *     is calling processBlock.  Use it from your UI or other threads to lock access to
 *     variables that are used by the process callback, but obviously be careful not to
 *     keep it locked for too long, because that could cause stuttering playback. If
 *     you need to do something that'll take a long time and need the processing to stop
 *     while it happens, use the suspendProcessing() method instead.
 *
 *   Not entirely sure what this does, I think it keeps processBlock from being entered
 *   for a brief period of time, probably not necessary with KernelCommunicator architecture.
 *
 * suspendProcessing
 *   "Enables and disables the processing callback.
 *   If you need to do something time-consuming on a thread and would like to make sure the audio
 *   processing callback doesn't happen until you've finished, use this to disable the
 *   callback and re-enable it again afterwards."
 *
 *   Might be useful for project loading?
 *
 *   "If the host tries to make an audio callback while processing is suspended, the processor will
 *    return an empty buffer, but won't block the audio thread like it would do if you use the
 *    getCallbackLock() critical section to synchronise access.
 *   Any code that calls processBlock() should call isSuspended() before doing so, and if the
 *   processor is suspended, it should avoid the call and emit silence or whatever is appropriate.
 *
 * virtual reset()
 *   override to be told when to reset any playing voices
 *   hmm, could be a GlobalReset hook?
 *
 * getActiveEditor
 *   not sure where I would use this, it says "should only call from the message thread"
 *
 * updateHostDisplay
 *   "The processor can call this when something (apart from a parameter value) has changed.
 *    It sends a hint to the host that something like the program, number of parameters,
 *    etc, has changed, and that it should update itself.
 *
 * ...all stuff related to Parameters...
 *
 * numChannelsChanged
 *    tell the host to rethink our channels, useful if you want to support dynamic
 *    port configuration
 *
 * addListener
 *   this is an override add a listener to receive notifications when something
 *   inside the plugin changes, I guess the host could call this, not sure why
 *
 * setPlayHead
 *   "tells the processor to use this playhead object"
 *   will want this
 *
 * setPlayConfigDetails
 * setRateAndBufferSizeDetails
 *    seems to be something the processor calls to tell the host it has desires
 *
 * updateTrackProperties
 *    "informs processor that track properties such as name or colour has changed"
 *    so what, we're supposed to care if they want it green?
 *
 */

#include "util/Trace.h"

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================

MobiusPluginAudioProcessor::MobiusPluginAudioProcessor()
#ifndef JucePlugin_PreferredChannelConfigurations
     : AudioProcessor (BusesProperties()
                     #if ! JucePlugin_IsMidiEffect
                      #if ! JucePlugin_IsSynth
                       .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
                      #endif
                       .withOutput ("Output", juce::AudioChannelSet::stereo(), true)
                     #endif
                       )
#endif
{
    // set this early in case we're not connecting Supervisor and just want
    // to watch plugin methods get called
    TraceDebugLevel = 2;

    // I'm really starting to hate this RAII shit, at least for massive
    // things like Supervisor.  It's going to build out EVERYTHING before
    // we've even know what the host is going to want.  If it's just
    // scanning plugins, we've done all that UI configuration for nothing
    // RootLocator::whereAmI();

    // the environment we're in is conceptually like the MainComponent
    // constructor when running standalone
    // Supervisor is a static member and we start it
    supervisor.start();
}

MobiusPluginAudioProcessor::~MobiusPluginAudioProcessor()
{
    // unlike MainComponent we don't shutdownAudio here
    // so it is unclear when exactly we can be sure processBlock will no
    // longer be called

    supervisor.shutdown();
}

void MobiusPluginAudioProcessor::reset()
{
    Trace(2, "MobiusPluginAudioProcessor::reset\n");
}

//==============================================================================

//
// I'm leaving the generated code mostly in place and using
// the JucePlugin symbols though we could dispense with that
// and just hard code them
//

const juce::String MobiusPluginAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

/**
 * Should always be true
 */
bool MobiusPluginAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

/**
 * Should always be true
 */
bool MobiusPluginAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

/**
 * Should always be false. This makes some hosts think
 * that we won't need any audio pins.
 */
bool MobiusPluginAudioProcessor::isMidiEffect() const
{
   #if JucePlugin_IsMidiEffect
    return true;
   #else
    return false;
   #endif
}

/**
 * This could be interesting, if you've got a loop going
 * and you suspend the plugin, we could do a GlobalReset
 * and add a fade tail.
 */
double MobiusPluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

/**
 * I think in olden times, we let Presets be our "programs".
 * This was never very useful.  The closest thing for Mobius might
 * be Projects, but that's a very heavy weight thing to be casually
 * flipping around in a host menu.
 */
int MobiusPluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MobiusPluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

/**
 * Set all you want, we follow our own path.
 */
void MobiusPluginAudioProcessor::setCurrentProgram (int index)
{
    (void)index;
}

/**
 * Here Juce just returned an empty string with {}
 * Rather than Projects or Setups I suppose we could a few useful
 * configurations of Setups with some minimal content that is a subset
 * of the saved Projects.
 */
const juce::String MobiusPluginAudioProcessor::getProgramName (int index)
{
    (void)index;
    // return {};
    return juce::String("Standard");
}

void MobiusPluginAudioProcessor::changeProgramName (int index, const juce::String& newName)
{
    (void)index;
    (void)newName;
}

//==============================================================================

/**
 * This is where it starts gettting interesting.
 * Forward audio block processing to Supervisor.
 */
void MobiusPluginAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    supervisor.prepareToPlayPlugin(sampleRate, samplesPerBlock);
}

void MobiusPluginAudioProcessor::releaseResources()
{
    supervisor.releaseResourcesPlugin();
}

/**
 * This we will want to eventually deal with.
 * I have Projucer configured with the simplfied bus layouts {2,2},{4,4}
 * so this should be bypassed.
 */
#ifndef JucePlugin_PreferredChannelConfigurations
bool MobiusPluginAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
  #if JucePlugin_IsMidiEffect
    juce::ignoreUnused (layouts);
    return true;
  #else
    // This is the place where you check if the layout is supported.
    // In this template code we only support mono or stereo.
    // Some plugin hosts, such as certain GarageBand versions, will only
    // load plugins that support stereo bus layouts.
    if (layouts.getMainOutputChannelSet() != juce::AudioChannelSet::mono()
     && layouts.getMainOutputChannelSet() != juce::AudioChannelSet::stereo())
        return false;

    // This checks if the input layout matches the output layout
   #if ! JucePlugin_IsSynth
    if (layouts.getMainOutputChannelSet() != layouts.getMainInputChannelSet())
        return false;
   #endif

    return true;
  #endif
}
#endif

/**
 * I moved the boilerplate code over to Supervisor
 * as a starting point.
 */
void MobiusPluginAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
{
    supervisor.processBlockPlugin(buffer, midiMessages);
}

//==============================================================================

/**
 * Always have, always will.
 */
bool MobiusPluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

/**
 * Generated code always created a new one of these
 * and I assume it gets deleted automatically when the host
 * window closes.  Pass along Supervisor since it will always need it.
 */
juce::AudioProcessorEditor* MobiusPluginAudioProcessor::createEditor()
{
    bool genericEditor = false;

    if (genericEditor)
      return new juce::GenericAudioProcessorEditor (*this);
    else
      return new MobiusPluginAudioProcessorEditor (*this, &supervisor);
}

//==============================================================================

/**
 * I'd like to support this someday, but I'm not sure I ever did before.
 * What would be useful here?  I guess a snapshot of the exported UIParameters
 * that were bound, but don't really need this since everything is in mobius.xml.
 */
void MobiusPluginAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    (void)destData;
}

void MobiusPluginAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    (void)data;
    (void)sizeInBytes;
}

//==============================================================================

// This creates new instances of the plugin..
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MobiusPluginAudioProcessor();
}
