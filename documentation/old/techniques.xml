<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE document>
<document>
<heading>
<title>Mobius Techniques</title>
<date>March 2012</date>
</heading>

<TOC/>

<!-- ======================================================================

  Techniques

====================================================================== -->

<section><title>Introduction</title>

<p>This document contains a sampling of common recording and performance
techniques used with Mobius.  You do not need to read this top to bottom,
look at the index and skip to the sections that interest you.</p>

<p>Note that this document is not yet complete.  Many sections are still
empty.  If you have an interest in an empty section post a request to the
forum and we will provide more information there.</p>

</section>

<!-- ======================================================================

  Record

  Record, SUSRecord, AutoRecord, Rehearse, SUSRehearse
  RecordResetsFeedback
  SpeedRecord
  RecordThreshold
  RecordTempo, RecordBeats, RecordBars

====================================================================== -->

<section><title>Record</title>

<p>The <i>Record</i> function is used to record new loops of live audio.
There are several ways to start and stop a recording, in the
simplest case you press the Record button once to begin recording,
and again to stop recording.  Immediately after the second press the loop
begins playing and continues until you alter it with another function.</p>

<p>Before a loop is recorded for the first time, the loop is
in <i>reset mode</i> and you will see the word <b>Reset</b> appear
in the status display.  While a loop is recording you are in <i>record
mode</i>
and will see the word <b>Record</b> in the status display.  Unless
and advanced record ending option is used, when the recording completes
the loop will enter <i>play mode</i> and <b>Play</b> will appear in the
status display.</p>

<p>If you want to discard the loop and start over you can use
the <ref>Reset</ref> function to stop the loop, release all loop memory
and return to reset mode.  From there you can use the Record function
again to record another loop.</p>

<p>If you want to discard the loop and immediately begin recording
a new one just press Record again with while the loop is playing.
The memory for the previous loop is not released until you
end the new recording, you can use the <i>Undo</i> function
to cancel the new recording and return to the original loop.  Note
that Undo only restores the previous loop if the previous loop
was not empty (in reset mode). Once a loop is reset all history of
the loop is gone, you cannot undo from reset mode.</p>

<p>Another way to reset a loop is to press and hold the Record
button.  This is referred to as a "Long Press Record" and it
behaves the same as the <ref>Reset</ref> function.  Using
long press Record to reset the loop is a common technique when using
a MIDI footswitch.   Since you will almost always have a footswitch
bound to the Record function you don't need to waste a footswitch
bound to the Reset function, you can simply do a long press of
the Record footswitch to do a reset.  The loop will enter record
mode for about 1/2 second (or whatever the configured long press
interval is) then the loop will be reset.</p>

<p>Once the loop has been recorded to your satisfaction, you may
begin modifying it, or combining it with loops on other tracks.</p>

<section><title>Sustain Record</title>

<p>The function <i>Sustain Record</i> is used with triggers that can
communicate both a "pressed" and "released" state.  The recording starts
when the trigger is pressed and stops when it is released.  For a
footswitch that sends MIDI notes, the recording would start when
the footswitch was pressed, continue while the footswitch was held,
and stop when the footswitch was released.   This can make it easier
to record very short loops.</p>

<p>If the Sustain Record function is bound to a trigger that does
not support press/release states, such as a MIDI program change,
it will behave the same as the Record function, requiring two presses
to start and ending the recording.</p>

</section> <!-- Sustain Record -->

<section><title>Record Mode</title>

<p>The preset parameter <i>Record Mode</i> can be used to change the
way the Record function behaves.   It has these values:</p>

<ul>
<li><b>Toggle</b> - the default, one press to start and another to stop</li>
<li><b>Sustain</b> - forces Record to behave like Sustain Record</li>
<li><b>Safe</b> - </li>
</ul>

<p>RecordMode=Safe should be it's own option so you can use it
with both toggle and sustain recording.</p>

</section> <!-- Record Mode -->

<section><title>Reverse Recording</title>
</section>

<section><title id='speedShiftRecording'>Speed Shifted Recording</title>
</section>

<section><title>Auto Record Function</title>
</section>

<section><title>Synchronized Recording</title>

<p>Synchronized recording is a very complex topic that is covered
fully in the <a href='synchronization.htm'>Mobius Synchronization</a> manual.</p>

</section>

<section><title>Threshold Recording</title>
</section>

<section><title>Generating MIDI Clocks</title>

<p>See the <a href='synchronization.htm#MIDI Master Sync'>MIDI Master Sync</a>
section of the <i>Mobius Synchronization</i> manual for more information.</p>

</section>

<section><title>Alternate Endings</title>
  Undo - cancel and return to original loop
  Insert - does an Insert, Replace, Rehearse, or Reverse depending on
    Insert Mode
  Mute - mute immediately
  Overdub - immediately enter overdub to get a seamless loop
  NextLoop - end and go to next loop
</section>

<section><title>Long Press Record</title>
</section>

<section><title>Auto Record</title>
</section>

<section><title>Rehearse</title>
</section>


</section> <!-- Record -->

<!-- ======================================================================

  Overdub

====================================================================== -->

<section><title>Overdub</title>

<p>Overdubbing is the process of adding new sound to an existing loop.
It is the most common way to modify loops after recording.  When
overdub is enabled, new sound coming into a track will be merged with
the loop that is currently playing in that track.  This will result in
a new loop containing both the original sound and the new sound.</p>

<p>Unlike many loopers, overdub in Mobius does not replace the
original loop.  Instead overdubbing creates a new "layer".  Remember
that loops are not single audio recordings, they are actually made up
of several audio recordings called layers.  Each time you modify a
loop a new layer is created.  If you don't like the results of a
modification you can return the previous layer with the <i>Undo</i>
function.</p>

<p>Overdub is controlled with the following functions.</p>

<ul>
<li>Overdub</li>
<li>Sustain Overdub</li>
<li>Overdub On</li>
<li>Overdub Off</li>
</ul>

<p>The <i>Overdub</i> function will toggle overdub on and off
each time it is used.</p>

<p>The <i>Sustain Overdub</i> function will turn overdub on when the
function button is pressed and turn it off when the button is
released.  It must be used with a <i>sustainable trigger</i>.  This is
useful if you want to create very short overdubs.  Pressing, holding,
then releasing a button is much faster than trying to press a button
twice.</p>

<p>The <i>Overdub On</i> and <i>Overdub Off</i> functions turn overdub
on and off without toggling.  They are intended for use in scripts
where you want to set the overdub state without worrying about the
current state.</p>.

<p>When a loop is playing, it is actually one of the layers in the
loop that is playing.  This is called the "active layer".
The active layer is usually the last layer that was created, if
you are displaying the <a href='exploring.htm#Layer Bars'>Layer Bars</a>
in the Mobius window, the active layer will be highlighted.  While
overdub is on, a new layer is continually being created as the active
layer plays.  This new layer will contain a copy of what is in the
active layer adjusted for feedback, then merged with the sound coming
into the track adjusted by the track's input level.  When the active
layer plays to the end, the new layer with the overdub is "shifted"
and becomes the active layer.  The overdubbed layer then begins
playing and a new layer is created to record the next overdub.  This
process continues for as long as overdub is enabled.  This means that
if you never turn overdub off you may generate a lot of layers.</p>

<p>If you decide you don't like an overdub, you can use the
<i>Undo</i> function to discard the new layer and return to the
previous layer.  You can keep using <i>Undo</i> to go all the way back
in time to the very first layer, then start overdubbing again.  See
the <ref>Managing Layers</ref> section for more information on using
<i>Undo</i>.</p>

<section><title>Ending Record with Overdub</title>

<p>A very useful technique is ending a new loop recording with
the <i>Overdub</i> function.  You start by pressing <i>Record</i> to
begin recording a new loop, then when you're ready to stop instead of
pressing <i>Record</i> again, press <i>Overdub</i>.  The new loop
is created and begins playing and you are immediately placed
in <i>Overdub</i> mode.  This is important because when you transition
seamlessly from  <i>Record</i> mode to <i>Overdub</i> mode we can avoid
a fade at the end of the loop.</p>

<p>Normally when you record a loop by pressing
<i>Record</i> twice, the left and right edges of the loop are 
automatically faded to zero.  This ensure that there will be no
abrupt changes in sample level at the loop start point.  Without these
fades you would usually hear a sharp "click" every time the loop
reached its end point and begin playing from the beginning because
the audio waveform at the end of the loop would not exactly align 
with the audio waveform at the beginning of the loop.</p>

<p>The consequence of these edge fades is that you can't create a loop
that lets a sound such as a reverb tail or a cymbal crash carry over
from the end of the loop back to the start and keep going.  Any sound
at the end of the loop will be abruptly cut off and faded to zero.</p>

<p>When you end a recording with <i>Overdub</i> the right edge fade
will not be done so the sound being recorded at the end of the loop
will seamlessly carry over to the to the beginning of the next
layer. You will hear the cymbal crash or the reverb tail cross the
loop boundary without a "fade bump".  You can now leave overdub on
indefinitely or wait just long enough for the sound to decay nicely
then press <i>Overdub</i> again to end the overdub.  This can result
in much more natural sounding loops because the end of the loop will
gradually blend with the start of the loop.</p>

</section> <!-- End Record with Overdub -->

<section><title>Overdub Mode</title>

<p>A loop is always in one <i>major mode</i> which is displayed in
the <a href='starting.htm#Mode'>Mode</a> component in the user
interface.  The default major mode is <i>Play</i>.  The loop will
always return to <i>Play</i> mode when no other modes are active.
Most major modes are temporary, they begin when you execute a <i>modal
function</i> such as <i>Record</i>, <i>Multiply</i>, or <i>Insert</i>
and then end when you execute that function again.  These are
called <i>function modes</i>.  If you are already in a function mode
and then execute a different function, the previous mode is canceled
and will not be restored.  For example if a loop is in <i>Multiply</i>
mode and you execute the <i>Insert</i> function, the <i>Multiply</i>
mode is canceled and the loop enters <i>Insert</i> mode.  Later when
you execute the <i>Insert</i> function again to end <i>Insert</i> mode
the loop will not return to the previous <i>Multiply</i> mode, it will
return to <i>Play</i> mode.</p>

<p>A loop may be in any number of <i>minor modes</i> at the same time,
these are displayed in the
<a href='starting.htm#minorModesComponent'>Minor Modes</a>
component in the user interface. Examples of minor modes include
<i>Reverse</i>, <i>Speed Toggle</i>, and <i>Pitch Step</i>. Minor modes
are not canceled when you change major modes.  For example if you start
in the <i>Reverse</i> minor mode when you execute the <i>Multiply</i> 
function, the major mode will change to <i>Multiply</i> but
<i>Reverse</i> minor mode will still be active.  Later when you leave
<i>Multiply</i> mode and return to <i>Play</i> mode, <i>Reverse</i> 
will continue to be active.</p>

<p><i>Overdub</i> is unusual because it has characteristics of
both <i>major</i> and <i>minor</i> modes.  Like a major mode it will
be displayed in the <a href='starting.htm#Mode'>Mode</a> component in
the user interface when it is active.  But like a minor mode
<i>Overdub</i> is not canceled when the major mode changes, it is 
just temporarily suspended.  It will also be displayed in the
<a href='starting.htm#minorModesComponent'>Minor Modes</a>
component in the user interface so you can see when it has been suspended.</p>

<p>For example if you start in <i>Overdub</i> mode and execute
the <i>Multiply</i> function, the major mode will change
to <i>Multiply</i> and <i>Overdub</i> is suspended.  Later when you
leave <i>Multiply</i> mode you will return to <i>Overdub</i>
mode. <i>Overdub</i> is the only major mode that behaves this way.</p>

</section> <!-- Overdub Major/Minor Modes -->

<section><title>Noise Floor</title>

<p>You may want to leave overdub on while you listen to the loop a few
times with your instrument muted.  While you are listening the loop
without playing you usually don't want more layers to be created
just because overdub was left on.  Mobius will only generate a new
layer if the maximum signal level of the sound received by the track
exceeds a threshold.  This threshold is set with the <i>Noise Floor</i>
global parameter.</p>

<p>Most instruments generate some low-level noise when they are not
being played.  Keyboards may hiss or buzz, guitars generate lots of
handling and string noise.  If you see layers being added when you are
not playing your instrument you may need to increase the <i>Noise
Floor</i> value.  If the value is zero then there will be no noise
filter and every pass of the loop while overdub is on will generate a
new layer.  The default value is 15 which is adequate for most
instruments including guitars with quiet pickups.  If you need to
raise the noise floor, increase the value by 5 or 10 until layers are
no longer being created.  You should not have to set this value
above 1000, if you do please let us know.  Be careful not to set
the <i>Noise Floor</i> too high or else overdubs may be lost if you
are playing softly.</p>

</section> <!-- Noise Floor -->

<section><title>Reduce Feedback During Overdub</title>

<p>If you are overdubbing a loud audio signal you need to be careful
not to overload the loop.  Mobius does not do any compression or
limiting, if you overdub loud sounds over loud sounds you may exceed
the maximum level which will cause harsh digital clipping.  If this
happens you will need to reduce the track input level or reduce
feedback.  Reducing the input level makes the new overdubbed sound
quieter, reducing feedback makes the sound being copied from the
current loop quieter.</p>

<p>If you prefer to leave the feedback control all the way up (127)
Mobius can still slightly reduce the amount of feedback
automatically while overdub is enabled.  The amount of feedback reduction is
small, approximately 5%.  This can help reduce clipping if you
overdub several times.</p>

<p>Normally this small amount of feedback reduction is not audible
but you can turn it off with a global parameter.  Open the
<i>Global Parameters</i> window and locate the checkbox labeled
<i>Reduce Feedback During Overdub</i>, uncheck the box to turn
this feature off.</p>

</section> <!-- Reduce Feedback During Overdub -->

<section><title>Overdub Quantized</title>

<p>Normally the overdub functions do not obey the <i>Quantize</i>
parameter, they are executed immediately when you press the function
trigger.  This is because you are usually merging new sound into an
existing sound so controlling exactly where the "edges" of the overdub
will be is not critical.  If you start overdub a little early, just
keep your instrument muted until you are ready to add something then
mute it when you're done.</p>

<p>Quantized overdub can however be useful as an effect.  If you keep
a loud sound playing before and after the overdub, you can drop in
overdubs that a very sharp attack and decay.  To enable overdub
quantization edit the preset and check the box labeled <i>Overdub
Quantized</i>.</p>

</section> <!-- Overdub Quantized -->

<!-- TODO: Long Overdub is supposed to convert to SUSOverdub,
we don't implement that yet -->

<!-- TODO: 4-45 talks about using Overdub during SamplerStyle=One
  will cancel the return.  If we do that, need to mention it in the
  SwitchDuration section. -->

<!-- TODO: 5-45 says SUSOverdub can continue while you use other
functions like Reverse and Halfspeed.  Need to explain this?
It's a general feature, all sus minor modes should work this way.
-->

</section> <!-- Overdub -->

<!-- ======================================================================

  Reset

  Reset, TrackReset, GlobalReset

====================================================================== -->

<section><title>Reset</title>
</section> <!-- Reset -->

<!-- ======================================================================

  Play

====================================================================== -->

<section><title>Play</title>
</section> <!-- Play -->

<!-- ======================================================================

  Layers

  Undo, Redo, Checkpoint
  MaxUndo, MaxRedo
  NoFeedbackUndo
  NoLayerFlattening

====================================================================== -->

<section><title>Managing Layers</title>
</section> <!-- Layers -->

<!-- ======================================================================

  Mute

  Mute, MuteOn, MuteOff, Pause, GlobalMute, GlobalPause, Solo
  SUSMute, SUSMuteRestart,
  MuteMode, MuteCancel, MuteSyncMode

====================================================================== -->

<section><title id='mutePause'>Mute, Pause, and Solo</title>
</section> <!-- Mute, Pause, Solo -->

<!-- ======================================================================

  Multiply

  Multiply, InstantMultiply, Stutter, SUSMultiply, SUSStutter
  MultiplyMode
  RecordDuringRounding

====================================================================== -->

<section><title id='multiply'>Extending The Loop With Multiply</title>
</section> <!-- Multiply -->

<!-- ======================================================================

  Insert

  Insert, SUSInsert, SUSUnroundedInsert

====================================================================== -->

<section><title id='insert'>Extending The Loop With Insert</title>
</section> <!-- Insert -->

<!-- ======================================================================

  Shortening

  Divide, DivideN, TrimStart, TrimEnd
  Multiply, SUSMultiply, Record alternate ending
  SUSUnroundedMultiply

====================================================================== -->

<section><title id='shortening'>Shortening The Loop</title>
</section> <!-- Shortening -->

<!-- ======================================================================

  Replace

  Replace, SUSReplace, Clear
  Substitute, SUSSubstitute
  AltFeedbackEnable
  ModesIgnoringSecondaryFeedback
  GP: AltFeedbackDisable

====================================================================== -->

<section><title id='replace'>Replacing Loop Content</title>
</section> <!-- Replace -->

<!-- ======================================================================

  Shuffle

   Shuffle
   ShuffleMode

====================================================================== -->

<section><title>Shuffle</title>
</section> <!-- Shuffle -->

<!-- ======================================================================

  Direction

  Reverse, SUSReverse, Forward, Backward

====================================================================== -->

<section><title>Changing Direction</title>
</section> <!-- Direction -->

<!-- ======================================================================

  Speed Shifting

  SpeedCancel, SpeedOctave, SpeedStep, SpeedBend
  SpeedUp, SpeedDown, SpeedNext, SpeedPrev
  SpeedToggle, SUSSpeedToggle, Halfspeed

  PP: SpeedSequence, SpeedBendRange, SpeedStepRange
  PP: SpeedRecord, SpeedShiftRestart
  GP: ShiftRange
  SP: SpeedSyncAdjust

====================================================================== -->

<section><title id='speedShift'>Speed Shift</title>

<p>The <i>speed shifting</i> features allow you to adjust the playback
and recording speed of the loop so that both the perceived pitch and
tempo of the loop change.  The most commonly known variant of speed
shift drops the playback speed by one octave which many loopers
call "halfspeed" mode.</p>

<p>Mobius offers a powerful set of functions and controls that
provide many ways to change loop speed beyond just one octave down.
The functions available for speed shifting are:</p>

<ul>
<li>Speed Toggle</li>
<li>Sustain Speed Toggle</li>
<li>Speed Step</li>
<li>Speed Up</li>
<li>Speed Down</li>
<li>Speed Next</li>
<li>Speed Previous</li>
<li>Halfspeed</li>
<li>Speed Cancel</li>
</ul>

<p>The controls available for speed shifting are:</p>

<ul>
<li>Speed Octave</li>
<li>Speed Step</li>
<li>Speed Bend</li>
</ul>

<p>The speed of the loop may be changed in either semitone steps
or with very small steps to achieve a smooth continuous shift.
Most of the functions and controls apply a semitone shift, 
The <ref>Speed Bend</ref> control applies a smooth continuous
shift.</p>

<section><title>Speed Functions</title>

<section><title id='speedToggle'>Speed Toggle, Sustain Speed Toggle</title>

<p>The most commonly used speed shifting function is <i>Speed Toggle</i>.
In its default behavior, it will lower the speed of the loop by one octave,
then raise it an octave when executed a second time.  This is what
many loopers including the EDP call "Half Speed".</p>

<p><i>Speed Toggle</i> is however able to do other things besides halfspeed.
When used in a script or with binding arguments, it can toggle between
any semitone shift up or down.   See the 
<a href='exploring.htm#functionArgs'>Function Binding Arguments</a> section
of the <i>Exploring Mobius</i> manual for more information on using
binding arguments.</p>

<p>For example when the binding argument is set to 7, the first press
of the function will raise the speed by 7 semitones, or a perfect fifth.  
The second press will lower it by 7 semitones.  If no argument is specified
the default interval is -12 which makes <i>Speed Toggle</i> behave like 
half speed functions in other loopers.</p>

<p>The <i>Sustain Speed Toggle</i> function behaves like <i>Speed Toggle</i>
except that you do not execute it twice.  It must be bound to a sustainable
trigger such as a MIDI note.  The speed shift is active while the trigger
is held down and removed when the trigger is released.</p>

<p><i>Speed Toggle</i> has long press behavior.  If you have <i>Speed Toggle</i>
bound to a susutainable trigger, and you hold the trigger down longer than
the long-press threshold, the function will convert to 
<i>Sustain Speed Toggle</i> and the speed shift will be removed when the
trigger is released.</p>

</section> <!-- Speed Toggle -->

<section><title id='functionSpeedStep'>Speed Step</title>

<p><i>Speed Step</i> can change the playback speed of the loop up or
down in semitones.  It is
a <i>ranged</i> function which means that it is usually bound to a
trigger that supports a continuous range of values such as MIDI notes
or MIDI continuous controllers.  It is almost always bound to a MIDI
note from a keyboard so you can change speed chromatically by
playing the keyboard normally.  This can make Mobius behave somewhat
like a sampler.</p>

<p>The value of the note in the binding becomes the center point of the
shift range.  If you press this note the speed returns to normal.  If you
press notes on either side of the center note, the speed will be raised
or lowered by the corresponding number of semitones.  The range
of notes that will cause a speed shift is determined by the
<i>Speed/Pitch Note Range</i> global parameter.  For best results, it
is recommended that the center note use a MIDI channel that is not
being used for any other functions.  If a Speed Step note is already
assigned to another Mobius function, the previous function will have
priority.  To avoid these conflicts use a different channel.</p>

<p>The <ref>Speed Shift Restart</ref> preset parameter is often set
when using a ranged binding of <i>Speed Step</i>.  This will cause
the loop to be restarted whenever <i>Speed Step</i> is executed, 
similar to the way keyboard samplers behave.</p>

<p>When this function is bound to a MIDI continuous controller, the 0 to 
127 range of the controller is scaled to fit within the
<ref>Speed/Pitch Note Range</ref>.  A controller value of 64 is considered
"center" and will apply no speed shift.  Controller values on either
side of 64 will raise or lower the speed in semitones.</p>

<p>When this function is given a binding argument, the ranged behavior
is not enabled. Instead the binding argument specifies a fixed positive
or negative number of semitones.  Multiple bindings with different
arguments can be created to directly jump to desired speeds.</p>

<p><i>SpeedStep</i> may also be used in scripts but it is not ranged.
Instead the amount of shift is specified as an argument to the
function.
See <a href='scripts.xml#SpeedStep'>SpeedStep</a> in the
<i>Mobius Scripting</i> manual for usage examples.</p>

</section> <!-- Step --> 

<section><title id='speedUp'>Speed Up, Speed Down</title>

<p>This pair of functions simply raises or lowers the speed by one semitone.
You might use these if you want to raise or lower the speed in successive
semitone steps but don't want to create a separate
<ref id='functionSpeedStep'>Speed Step</ref>
bindings for each step.</p>

</section> <!-- Up, Down -->

<section><title id='speedNext'>Speed Next, Speed Previous</title>

<p>This pair of functions changes the speed in steps defined by the
<ref>Speed Sequence</ref> parameter.
The parameter may be set to a space-delimited list of numbers
that represents positive or negative speed shifts in semitone
steps.  For example a speed sequence of "7 12 0" will raise the
speed by a fifth, then by an octave, then return to normal.</p>

<p>The <i>Speed Next</i> function advances through the speed sequence
from left to right, and the <i>Speed Previous</i> function advances
through the sequence from right to left.  You can change direction at
any time.</p>

<p><b>NOTE:</b> The current location in the speed sequence is not
shown in the UI which can make this difficult to use.  The location
is available in scripts with the 
<a href='scripts.htm#speedSequenceIndex'>speedSequenceIndex</a> variable.
This variable may also be set to change the sequence index.</p>

</section> <!-- Next, Prev --> 
 
<section><title>Halfspeed</title>

<p><i>Halfspeed</i> is an obsolete function that is provided only
for backward compatibility with older scripts and bindings. It forces
a non-toggling speed shift of one octave down.  The same behavior
is possible by creating a binding to
<ref id='functionSpeedStep'>Speed Step</ref> with an argument of -12.</p>

</section>

<section><title>Speed Cancel</title>

<p><i>Speed Cancel</i> will remove all forms of semitone and continuous 
speed shift being applied to the track.  It will cancel the effects of all
speed functions and the speed controls, and reset the <i>Speed Sequence</i>
index back to the beginning.</p>

<p>This can be useful to get things back to normal if you have been
combining <i>Speed Step</i>, <i>Speed Bend</i>
and <i>Speed Octave</i> in various ways without having to individually
cancel each function and return the controls to their center positions.</p>

</section> <!-- Cancel --> 

</section> <!-- Speed Functions -->

<section><title>Speed Controls</title>

<p>There are three controls that may be added to the track 
strips to display and change speed.</p>

<image src='images/techniques-speed-controls.gif' 
  caption='Speed Controls'/>

<section><title>Speed Octave</title>

<p><i>Speed Octave</i> is a control that can be used to change
the speed up or down by one or more octaves.  The maximum range
is 4 octaves up or down.  When bound to a MIDI continuous controller,
the controller will sweep through a range of 8 octaves.  The
center value of 64 will result in no shift.</p>

</section>

<section><title id='controlSpeedStep'>Speed Step</title>

<p><i>Speed Step</i> will appear as both a control and a function
in the binding windows.  You can achieve similar effects with either
target, but main difference is the way in which the binding arguments
are handled.</p>

<p>When <i>Speed Step</i> is bound as a control, the binding arguments
must follow the conventions of
<a href='exploring.htm#Control Binding Arguments'>Control Binding Arguments</a>
which have values such as <i>min</i>, <i>max</i> and <i>center</i>.</p>

<p>When <i>Speed Step</i> is bound as a function, the binding argument
may only have a single integer value which specifies the amount
of speed shift in semitones.</p>

<p>Another difference between the <i>Speed Step</i> control and 
function is the range of values.  The <i>Speed Step</i> control range
is defined by the <ref>Speed Step Range</ref> preset parameter which
defaults to 24, meaning two octaves up and down.  The <i>Speed Step</i>
function range is defined by the global parameter 
<ref>Speed/Pitch Note Range</ref>.  Because the control range
is defined by a preset parameter, you can design prests with different
ranges if for example you want a control that sweeps over a smaller
range of semitones.</p>

</section>

<section><title>Speed Bend</title>

<p><i>Speed Bend</i> is a control that can be used to change the
speed up or down by very fine units resulting in a seemingly
smooth or "continuous" speed change.  The effect is similar to using
the pitch bend wheel on a keyboard, except that it changes the
speed as well as the pitch.</p>

<p>Unlike most controls, this one is commonly bound to the
MIDI <i>Pitch Bend</i> trigger which has a larger range of values
resulting in smoother bends.  You may also bind this to a 
MIDI continuous controller, but these have less range and may result
in a more audible "zipper" sound as you hear the speed change in 
small steps.</p>

<p>The internal range of the speed bend control is defined
by the <ref>Speed Bend Range</ref> parameter.  This defaults to 12
which means one octave up or down.</p>

<p>Note how the range of the external trigger and the internal control
range combine.  If you set <i>Speed Bend Range</i> to 1 for one semitone
up or down, and then bind the control to a MIDI Pitch Bend wheel, you
will get an extremely smooth speed shift because a range of 2 semitones
will be divided into 16384 steps.  Binding to a MIDI continuous controller
by comparison will only divide the semitone range into 128 steps.</p>

</section> <!-- Speed Bend -->

</section> <!-- Speed Controls -->

<section><title>Speed Parameters</title>

<p>Most speed-related parameters are found under the <i>Effects</i>
tab of the preset window.</p>

<image src='images/starting-preset-effects.gif'
       caption='Speed Parameters'/>

<section><title>Speed Sequence</title>

<p>This is a preset parameter found under the <i>Effects</i> tab. It
may be set set to a space-delimited list of numbers
that represents positive or negative speed shifts in semitone
increments.  For example a speed of "1" is one semitone above normal, a
speed of "-7" is 7 semitones below normal (or a perfect fifth lower).
Once a speed sequence has been set, the speed may be changed using
the <ref id='speedNext'>Speed Next</ref> and 
<ref id='speedNext'>Speed Previous</ref> functions.</p>

</section> <!-- Speed Sequence -->

<section><title>Speed Step Range</title>

<p>This parameter defines the range of the
<ref id='controlSpeedStep'>Speed Step</ref> control.  
The default value of 24 means that the range is
24 semitones, or 2 octaves up and down for a total range of 48 semitones.
The smallest value is 1 which gives you a range of 2 semitones, 
one up and one down.</p>

<p>You may wish to lower the step range when binding to a MIDI
continuous controller to give you more control when selecting steps.
If the range is too high, very slight changes to the knob or pedal 
will change speeds.  With a lower range, the knob or pedal must
move a longer distance before changing speeds.</p>

</section> <!-- Speed Step Range -->

<section><title>Speed Bend Range</title>

<p>This parameter defines the range of the
<ref>Speed Bend</ref> control.  
The default value of 12 means that the range is
12 semitones, or 1 octave up and down for a total range of 24 semitones.
The smallest value is 1 which gives you a range of 2 semitones, 
one up and one down.</p>

<p>You may wish to lower the bend range when binding to a MIDI
continuous controller to give you a smoother and more subtle bend.</p>

</section> <!-- Speed Bend Range -->

<section><title>Record Speed Changes</title>

<p>This boolean preset parameter is found under the <i>General</i> tab.  
When false it means that using any of the speed functions or controls
will end a recording if one is in progress.</p>

</section> <!-- Record Speed Changes -->

<section><title>Speed Shift Restart</title>

<p>When this boolean parameter is true, the current loop will be
restarted from the beginning whenever the playback speed is
changed by the <ref id='speedUp'>Speed Up</ref>, <ref id='speedUp'>Speed Down</ref>, 
<ref>Speed Cancel</ref>, <ref id='speedNext'>Speed Next</ref>, 
<ref id='speedNext'>Speed Previous</ref>, and
<ref id='functionSpeedStep'>Speed Step</ref> functions.</p>

<p>This is commonly used when doing a ranged MIDI note binding
to the <i>Speed Step</i> function so that Mobius will behave simlilar
to a keyboard sampler.  Once the loop is recorded, you can play
it chromatically on the keyboard, retrigging the loop with each new note.</p>

</section> <!-- Speed Shift Restart -->

<section><title>Speed/Pitch Note Range</title>

<p>This parameter defines the range of MIDI notes or controller values
that will be automatically bound to the
<ref id='functionSpeedStep'>Speed Step</ref> or 
<ref id='functionPitchStep'>Pitch Step</ref> functions.  The center of the range
is defined by the note or control selected in the binding window.
The parameter is found under the <i>Miscellaneous</i> tab of
the <i>Global Parameters</i> window.</p>

<p>The default value is 48 which will result in an 8 octave range to 
cover an entire MIDI keyboard.  There is usually no need to change this, but
you can specify a smaller range if desired.</p>

</section> <!-- Speed/Pitch Note Range -->

</section> <!-- Speed Parameters -->

<section><title>Speed Combinations</title>

<p>You may use all of the speed functions and controls at the same time.
For example if you turn the <i>Speed Octave</i> control to -1, then
turn the <i>Speed Step</i> control to 12, the effect will be normal
speed since when you add the effects of drop of one octave (-12 semitones)
to a rise of 12 semitones, you get 0 semitones.  No speed shift will be 
heard.</p>

<p>This can be especially usefull with <ref>Speed Bend</ref>.  <i>Speed Bend</i>
typically has a range of one octave up or down or lower if you 
want a smoother bend.  By combining this with <i>Speed Octave</i> you
can radically change the speed of the loop, then give it a subtle vibrato
in any octave with <i>Speed Bend</i>.</p>

<p>Note that the combination of speed functions and controls 
are restricted to a maximum of 4 octaves up or down.  For
example if you have used the <i>Speed Step</i> function to lower
speed by 24 semitones, then turned the <i>Speed Octave</i> control down to -4
you will not get a combined shift of 6 octaves down.  The shift will be 
constrained to 4 octaves down.  The <i>Speed Octave</i> control values of
-3 and -4 will appear to do nothing until you raise it above -2.</p>

<p>Similarly if you have <i>Speed Octave</i> set to 4, the upper half
of the <i>Speed Bend</i> control will appear to have no effect since the
speed cannot be raised any more.</p>

</section> <!-- Speed Combinations -->

</section> <!-- Speed Shift -->

<!-- ======================================================================

  Pitch Shift

  PitchCancel, PitchUp, PitchDown, PitchNext, PitchPrev, PitchStep
  PitchOctave, PitchStep, PitchBend

  PP: PitchSequence, PitchShiftRestart
  GP: ShiftRange, PitchStepRange, PitchBendRange

====================================================================== -->

<section><title id='pitchShift'>Pitch Shift</title>

<p>NOTE: Pitch Shifting is still considered a "beta" feature.  It can
be fun to play with, but the algorighm introduces a significant amount
of additional latency when it is active, and this is not being properly
compensated.  This makes it difficult to use pitch shifting when
you are trying to synchronize multiple tracks with different amounts
of shift, or if you are synchroning Mobius to an external device.</p>

<p>Pitch shift is very similar to <ref id='speedShift'>Speed Shift</ref> except
that the pitch is changed without changing the length or tempo of the loop.  In
all other respects the functions and parameters used to control pitch
shifting are almost identical to those for speed shifting.</p>

<p>Pitch shifting may be controlled using these functions and controls.</p>

<ul>
<li>Pitch Step</li>
<li>Pitch Up</li>
<li>Pitch Down</li>
<li>Pitch Next</li>
<li>Pitch Previous</li>
<li>Pitch Cancel</li>
<li>Pitch Octave</li>
<li>Pitch Bend</li>
</ul>

<section><title>Pitch Functions</title>

<section><title id='functionPitchStep'>Pitch Step</title>

<p><i>Pitch Step</i> can change the pitch of the loop up or
down in semitones.  It is
a <i>ranged</i> function which means that it is usually bound to a
trigger that supports a continuous range of values such as MIDI notes
or MIDI continuous controllers.  It is almost always bound to a MIDI
note from a keyboard so you can change pitch chromatically by
playing the keyboard normally.  This can make Mobius behave somewhat
like a sampler.</p>

<p>See the description of the <ref id='functionSpeedStep'>Speed Step</ref>
function for more details about how to create ranged function bindings.</p>

<p>The <ref>Pitch Shift Restart</ref> preset parameter is often set
when using a ranged binding of <i>Pitch Step</i>.  This will cause
the loop to be restarted whenever <i>Pitch Step</i> is executed, 
similar to the way keyboard samplers behave.</p>

<p><i>PitchStep</i> may also be used in scripts but it is not ranged.
Instead the amount of shift is specified as an argument to the
function.
See <a href='scripts.xml#PitchStep'>PitchStep</a> in the
<i>Mobius Scripting</i> manual for usage examples.</p>

</section> <!-- Step --> 

<section><title id='pitchUp'>Pitch Up, Pitch Down</title>

<p>This pair of functions simply raises or lowers the pitch by one semitone.
You might use these if you want to raise or lower the pitch in successive
semitone steps but don't want to create a separate
<ref id='functionPitchStep'>Pitch Step</ref>
bindings for each step.</p>

</section> <!-- Up, Down -->

<section><title id='pitchNext'>Pitch Next, Pitch Previous</title>

<p>This pair of functions changes the pitch in steps defined by the
<ref>Pitch Sequence</ref> parameter.
The parameter may be set to a space-delimited list of numbers
that represents positive or negative pitch shifts in semitone
steps.  For example a pitch sequence of "7 12 0" will raise the
pitch by a fifth, then by an octave, then return to normal.</p>

<p>The <i>Pitch Next</i> function advances through the pitch sequence
from left to right, and the <i>Pitch Previous</i> function advances
through the sequence from right to left.  You can change direction at
any time.</p>

<p><b>NOTE:</b> The current location in the pitch sequence is not
shown in the UI which can make this difficult to use.  The location
is available in scripts with the 
<a href='scripts.htm#pitchSequenceIndex'>pitchSequenceIndex</a> variable.
This variable may also be set to change the sequence index.</p>

</section> <!-- Next, Prev --> 
 
<section><title>Pitch Cancel</title>

<p><i>Pitch Cancel</i> will remove all forms of semitone and continuous 
pitch shift being applied to the track.  It will cancel the effects of all
pitch functions and pitch controls, and reset the <i>Pitch Sequence</i>
index back to the beginning.</p>

<p>This can be useful to get things back to normal if you have been
combining <i>Pitch Step</i>, <i>Pitch Bend</i>
and <i>Pitch Octave</i> in various ways without having to individually
cancel each function and return the controls to their center positions.</p>

</section> <!-- Cancel --> 

</section> <!-- Pitch Functions -->

<section><title>Pitch Controls</title>

<p>There are three controls that may be added to the track 
strips to display and change pitch.</p>

<image src='images/techniques-pitch-controls.gif' 
  caption='Pitch Controls'/>

<section><title>Pitch Octave</title>

<p><i>Pitch Octave</i> is a control that can be used to change
the pitch up or down by one or more octaves.  The maximum range
is 4 octaves up or down.  When bound to a MIDI continuous controller,
the controller will sweep through a range of 8 octaves.  The
center value of 64 will result in no shift.</p>

</section>

<section><title id='controlPitchStep'>Pitch Step</title>

<p><i>Pitch Step</i> will appear as both a control and a function
in the binding windows.  You can achieve similar effects with either
target, but main difference is the way in which the binding arguments
are handled.</p>

<p>When <i>Pitch Step</i> is bound as a control, the binding arguments
must follow the conventions of
<a href='exploring.htm#Control Binding Arguments'>Control Binding Arguments</a>
which have values such as <i>min</i>, <i>max</i> and <i>center</i>.</p>

<p>When <i>Pitch Step</i> is bound as a function, the binding argument
may only have a single integer value which specifies the amount
of shift in semitones.</p>

<p>Another difference between the <i>Pitch Step</i> control and 
function is the range of values.  The <i>Pitch Step</i> control range
is defined by the <ref>Pitch Step Range</ref> preset parameter which
defaults to 24, meaning two octaves up and down.  The <i>Pitch Step</i>
function range is defined by the global parameter 
<ref>Speed/Pitch Note Range</ref>.  Because the control range
is defined by a preset parameter, you can design prests with different
ranges if for example you want a control that sweeps over a smaller
range of semitones.</p>

</section>

<section><title>Pitch Bend</title>

<p><i>Pitch Bend</i> is a control that can be used to change the
pitch up or down by very fine units resulting in a seemingly
smooth or "continuous" pitch change.  The effect is similar to using
the pitch bend wheel on a keyboard.</p>

<p>Unlike most controls, this one is commonly bound to the
MIDI <i>Pitch Bend</i> trigger which has a larger range of values
resulting in smoother bends.  You may also bind this to a 
MIDI continuous controller, but these have less range and may result
in a more audible "zipper" sound as you hear the pitch change in 
small steps.</p>

<p>The internal range of the pitch bend control is defined
by the <ref>Pitch Bend Range</ref> parameter.  This defaults to 12
which means one octave up or down.</p>

</section> <!-- Pitch Bend -->

</section> <!-- Pitch Controls -->

<section><title>Pitch Parameters</title>

<p>Most pitch-related parameters are found under the <i>Effects</i>
tab of the preset window.</p>

<image src='images/starting-preset-effects.gif'
       caption='Pitch Parameters'/>

<section><title>Pitch Sequence</title>

<p>This is a preset parameter found under the <i>Effects</i> tab. It
may be set set to a space-delimited list of numbers
that represents positive or negative pitch shifts in semitone
increments.  For example a pitch of "1" is one semitone above normal, a
pitch of "-7" is 7 semitones below normal (or a perfect fifth lower).
Once a pitch sequence has been set, the pitch may be changed using
the <ref id='pitchNext'>Pitch Next</ref> and <ref id='pitchNext'>Pitch Previous</ref> functions.</p>

</section> <!-- Pitch Sequence -->

<section><title>Pitch Step Range</title>

<p>This parameter defines the range of the
<ref id='controlPitchStep'>Pitch Step</ref> control.  
The default value of 24 means that the range is
24 semitones, or 2 octaves up and down for a total range of 48 semitones.
The smallest value is 1 which gives you a range of 2 semitones, 
one up and one down.</p>

<p>You may wish to lower the step range when binding to a MIDI
continuous controller to give you more control when selecting steps.
If the range is too high, very slight changes to the knob or pedal 
will change pitches.  With a lower range, the knob or pedal must
move a longer distance before changing pitch.</p>

</section> <!-- Pitch Step Range -->

<section><title>Pitch Bend Range</title>

<p>This parameter defines the range of the
<ref>Pitch Bend</ref> control.  
The default value of 12 means that the range is
12 semitones, or 1 octave up and down for a total range of 24 semitones.
The smallest value is 1 which gives you a range of 2 semitones, 
one up and one down.</p>

<p>You may wish to lower the bend range when binding to a MIDI
continuous controller to give you a smoother and more subtle bend.</p>

</section> <!-- Pitch Bend Range -->

<section><title>Pitch Shift Restart</title>

<p>When this boolean parameter is true, the current loop will be
restarted from the beginning whenever the pitch is
changed by the <ref id='pitchUp'>Pitch Up</ref>, <ref id='pitchUp'>Pitch Down</ref>, 
<ref>Pitch Cancel</ref>, <ref id='pitchNext'>Pitch Next</ref>, <ref id='pitchNext'>Pitch Previous</ref>, and
<ref id='functionPitchStep'>Pitch Step</ref> functions.</p>

<p>This is commonly used when doing a ranged MIDI note binding
to the <i>Pitch Step</i> function so that Mobius will behave simlilar
to a keyboard sampler.  Once the loop is recorded, you can play
it chromatically on the keyboard, retrigging the loop with each new note.</p>

</section> <!-- Pitch Shift Restart -->

</section> <!-- Pitch Parameters -->

<section><title>Pitch Combinations</title>

<p>You may use all of the pitch functions and controls at the same time.
For example if you turn the <i>Pitch Octave</i> control to -1, then
turn the <i>Pitch Step</i> control to 12, the effect will be normal
pitch since when you add the effects of drop of one octave (-12 semitones)
to a rise of 12 semitones, you get 0 semitones.  No pitch shift will be 
heard.</p>

<p>Like <ref>Speed Combinations</ref>, the pitch shift range is limited
to 4 octaves up or down.</p>

</section> <!-- Pitch Combinations -->

</section> <!-- Pitch Shift -->

<!-- ======================================================================

  Time Stretch

====================================================================== -->

<section><title id='timeStretch'>Time Stretch</title>

<p><i>Time Stretch</i> is an effect that combines <ref id='speedShift'>Speed Shift</ref>
and <ref id='pitchShift'>Pitch Shift</ref> to change the length and tempo of a loop
without changing the pitch.  Note that because <i>Time Stretch</i>
relies on the <i>Pitch Shift</i> algorithm, it will have similar issues
regarding added latency which can cause synchronization problems and
a slight gap in the audio when as you change the amount of stretch.  These
issues will be addressed in future releases, until then we consider
this a "beta" feature that needs to be used with caution.</p>

<p>Time stretch is accomplished by binding to the <i>Time Stretch</i>
control, there are no functions for time stretch.  Like the
<ref>Speed Bend</ref> and <ref>Pitch Bend</ref> controls, this can
be bound to either the MIDI pitch wheel or to a continuous controller.
The internal range of the time stretch
control is defined by the <ref>Time Stretch Range</ref> preset parameter.</p>

<image src='images/techniques-stretch-controls.gif' 
  caption='Time Stretch Control'/>

<p>In the UI, the <i>Time Stretch</i> control will be shown with a value
of zero in the center position when there is no time stretch being applied.
When the MIDI pitch wheel is at the center position or the MIDI
continuous controller is held at value 64, the value of the control will be
zero and there is no time stretch.  As 
the trigger value rises, the loop is compressed so that it becomes shorter
and the tempo becomes faster.  As the trigger value falls, the loop is
expanded so that it becomes longer and the tempo becomes slower.</p>

<p>Although time stretch combines <i>Pitch Shift</i> and <i>Speed Shift</i>
it is not canceled by either the <ref>Pitch Cancel</ref> or 
<ref>Speed Cancel</ref> functions.  You must cancel time stretch by 
returning the <i>Time Stretch</i> control to its center position.</p>

<section><title>Time Stretch Range</title>

<p>The effective range of the time stretch is controlled by the
preset parameter <i>Time Stretch Range</i> found under the <i>Effects</i> tab.
The defalut value is 12.  Like <ref>Speed Bend Range</ref>, this value
is a number of semitones, where 12 means one octave up or down.</p>

<p>The notion of a semitone range is confusing when applied to time stretch,
since the purpose is to not change the pitch.  Instead think of it 
this way, a one octave speed shift down results in a loop that lasts
twice as long.  For time stretch, a one octave shift down also results
in a loop that is twice as long, but the pitch doesn't change.  So for
time stretch, the number 12 means the control has a range that will
either double the loop length or cut it in half, but the pitch will 
not change.</p>

</section> <!-- Time Stretch Range -->

<section><title>Combining Stretch, Pitch, and Speed</title>

<p>Since time stretch is just a combination of <ref id='speedShift'>Speed Shift</ref>
and <ref id='pitchShift'>Pitch Shift</ref> it can be used at the same time as the other
functions and controls for speed and pitch shifting.  For example if you
time stretch a loop to make it twice as long, then use <ref>Pitch Octave</ref>
to lower the pitch one ocatve, the result is the same as using the
<ref>Speed Octave</ref> control to lower the pitch and speed by one ocatve.
If you bind all of the speed, pitch, and stretch controls to knobs on 
a MIDI control surface, you can have a lot of fun mutating the loops
into unrecognizeable slow drones, or insect fights.</p>

</section> <!-- Combining Stretch -->

</section> <!-- Time Stretch -->

<!-- ======================================================================

  Loop Switching

  NextLoop, PrevLoop, LoopX, Restart, RestartOnce
  SUSNextLoop, SUSPrevLoop
  Confirm
  EmptyLoopMode
  OverdubTransfer, SpeedTransfer, ReverseTransfer, PitchTransfer
  SwitchLocation, SwitchDuration, ReturnLocation, SwitchQuantize
  TimeCopy, SoundCopy, SwitchVelocity

====================================================================== -->

<!-- TODO: 4-46 talks about combining SamplerStyle=One with
LoopCopy and TimeCopy so that as soon as the copy finishes you
can jump back to the previous loop.  Not sure if I support that.
-->

<!-- TODO: 4-49 talks about canceling Confirm mode with functions
other than Undo.  We don't do it that way, instead functions "stack"
until you confirm.  May want an option for "auto confirm".
-->

<section><title id='switching'>Loop Switching</title>

<p>Tracks may contain several loops but only one loop at a time can be
selected for playing or recording.  This is called the
<i>active loop</i>.  Changing the active loop in a track
a track is called <i>loop switching</i>.  Loop switching is
a complex topic because there are many options available to control when
the switch happens and what happens to the new loop after 
it is activated.</p>

<p>Often you will want to use <i>switch quantization</i> to control
when the loop switch will happen relative to the loop that is
currently playing.  This is important if you want to maintain a steady
rhythm, for example letting the current loop play to the end before
switching.</p>

<p>If the next loop is empty you will often want to automatically
begin recording into it, or copy portions of the current loop into it
so you can begin creating variations.</p>

<p>One of the most common uses for loop switching is to record
"song parts" such as verse A in loop 1, verse B in loop 2, and
a chorus in loop 3, then switch between those at rhythmically
precise times.</p>

<p>You can also use track loops as a primitive sample player where
each loop contains a different sound that when triggered plays
from beginning to end and then stops.</p>

<p>The following functions will do some form of loop switch.</p>

<ul>
<li><b>Next Loop</b></li>
<li><b>Previous Loop</b></li>
<li><b>Sustain Next Loop</b></li>
<li><b>Sustain Previous Loop</b></li>
<li><b>Loop 1</b></li>
<li><b>Loop 2</b></li>
<li><b>Loop 3</b></li>
<li><b>Loop 4</b></li>
<li><b>Loop 5</b></li>
<li><b>Loop 6</b></li>
<li><b>Loop 7</b></li>
<li><b>Loop 8</b></li>
<li><b>Restart</b></li>
<li><b>Restart Once</b></li>
</ul>

<p>The <i>Next Loop</i> function will activate the next loop in the
track.  If the last loop is currently active, <i>Next Loop</i> will
wrap back around and activate the first loop.  The <i>Previous
Loop</i> function works in the opposite direction, activating the
previous loop.  If the first loop is currently active <i>Previous
Loop</i> wraps and activates the last loop.</p>

<p>The <i>Sustain Next Loop</i> and <i>Sustain Previous Loop</i>
functions must be bound to a
<a href='starting.htm#Sustainable Trigger'>sustainable trigger</a>.  
If they are not, they behave the same as <i>Next Loop</i> and 
<i>Previous Loop</i>.  The sustain functions will switch to the new
loop while the function button is held down, then they return to the
original loop when the function button is released.  Note that
you can get sustain behavior with other loop switching functions
by setting the <ref>Switch Duration</ref> parameter.</p>

<p>The <i>Restart</i> function starts the current loop over from the
beginning.  It may not sound like this would be a loop switch but it
behaves like a switch away from and then immediately back to the
current loop.  The <i>RestartOnce</i> function restarts the current
loop, lets it play to the end and then automatically
enters <i>Mute</i> mode.</p>

<p>The numbered <i>Loop</i> functions switch directly to the numbered
loop.  If that loop is already selected these functions behave the
same as <i>Restart</i>.</p>

<section><title>Switch Quantize</title>

<p>If you want to maintain a steady rhythm as you switch between loops
you will usually want to use some form of <i>switch quantization</i>
to make the switch happen at an exact time.  Switch quantization is
not controlled by the <i>Quantize</i> parameter like most functions.
Instead there is a dedicated parameter named <i>Switch Quantize</i>
that is used for all loop switch functions.  This parameter may
have the following values.</p>

<ul>
<li><b>Off</b></li>
<li><b>Subcycle</b></li>
<li><b>Cycle</b></li>
<li><b>Loop</b></li>
<li><b>Confirm</b></li>
<li><b>Confirm Subcycle</b></li>
<li><b>Confirm Cycle</b></li>
<li><b>Confirm Loop</b></li>
</ul>

<p>When the value is <i>Off</i> the switch will happen immediately
when you press the function button.</p>

<p>When the value is <i>Subcycle</i>, <i>Cycle</i> or <i>Loop</i> the
switch will be delayed until the next quantization point.  You will
see a white event marker under the loop meter showing when the switch
will happen and the loop will enter <i>Switch</i> mode.</p>

<p>When one of the four <i>Confirm</i> values is selected, an extra
confirmation action will be required before the loop switch will
happen.  After you use any of the loop switch functions, the current
loop will first enter <i>Confirm</i> mode and wait there indefinitely.
You must then execute the <i>Confirm</i> function to confirm the
switch.  See the <ref>Switch Confirmation</ref> section for other
confirmation options.  What happens after the confirmation action
depends on which <i>Switch Quantize</i> parameter value was selected.
If the value was <i>Confirm</i> the switch will happen immediately.  If the
value was <i>Confirm Subcycle</i>, <i>Confirm Cycle</i>, or 
<i>Confirm Loop</i> the loop enters <i>Switch</i> mode and waits
for the next quantization point before switching.</p>

<p>Note that while you in either <i>Confirm</i> or <i>Switch</i> 
mode many functions will behave differently than they normally do.
This is sometimes referred to as the "switch quantization period" 
and by some older EDP users as "lame duck period".  This is described
in detail later in the <ref>Switch and Confirm Modes</ref> section.</p>

</section> <!-- Switch Quantize -->

<section><title>Switch Confirmation</title>

<p>If you have <ref>Switch Quantize</ref> set to any of values
beginning with the word "Confirm" you must execute another function to
cancel the confirmation mode and proceed with the loop switch.  The
default function for canceling confirmation mode is <i>Confirm</i>.
This function has no other use besides switch confirmation.  If you
try to execute it when the loop is not in <i>Confirm</i> mode it
will have no effect.</p>

<p>You may not want to assign one of the precious buttons on your foot
controller to the <i>Confirm</i> function since it is normally
useless.  It is possible to select other functions that will behave as
a switch confirmation action by setting the global parameter <i>Switch
Confirmation Functions</i>.  In the <i>Global Parameters</i> window,
select the <i>Functions</i> tab and locate the item selector
labeled <i>Switch Confirmation Functions</i>.  Select the functions
you want to use for confirmation and move them to the right.</p>

<p>If you are familiar with the EDP, you may want to use
the <i>Undo</i> function for confirmation since that is the only way
to do switch confirmation on the EDP.  We here at the labs don't like
using <i>Undo</i> for confirmation because it makes it impossible to
cancel the loop switch or remove "stacked" functions.  We recommend
one of the following functions that are often assigned to a footswitch
button but are not often used during the 
<ref id='Switch and Confirm Modes'>switch quantization period</ref>.</p>

<ul>
<li>Realign</li>
<li>Redo</li>
<li>Replace</li>
<li>Reset</li>
<li>Restart</li>
<li>Reverse</li>
<li>Speed</li>
<li>Substitute</li>
</ul>

<!-- don't need to say this since the can only select from
a provided list

<p>If is recommended that you do not select one of the following
functions since these have special behavior during the switch
quantization period.  If you do not need the special behavior you can
use them as confirmation functions but review the <ref>Switch and
Confirm Modes</ref> section to make sure you will not need them.</p>

<ul>
<li>Record</li>
<li>Overdub</li>
<li>Multiply</li>
<li>Insert</li>
</ul>
-->

</section> <!-- Switch Confirmation -->

<section><title>Switch and Confirm Modes</title>

<p>While a loop is in <i>Confirm</i> or <i>Switch</i> modes many
functions will behave differently than they normally do.  This is
sometimes referred to as the "switch quantization period" or by some
older uses as the "lame duck period".</p>

<p>Most functions you execute will simply be delayed until after the
switch.  This is called <i>function stacking</i>.  In the user
interface, you will see the function names stacking under the loop
switch event marker.  This can be used to queue up interesting
combinations of functions and have them all execute exactly at the
same time after the switch.  For example, putting the next loop
into <i>Reverse</i>, <i>Speed Toggle</i>, and
<i>Substitute</i> modes all at once.</p>

<p>Until the switch occurs you can use <i>Undo</i> to remove 
stacked functions if you trigger the wrong one or decide you don't 
want it.  Once you have removed all the stacked functions and you are
left with only the switch event marker, using <i>Undo</i> will cancel
the switch and leave you in the current loop.</p>

<p><b>NOTE:</b> The EDP uses <i>Undo</i> as the switch confirmation
action.  If you like this and have <i>Undo</i> set in the
<i>Switch Confirmation Functions</i> global parameter, then you will not
be able to use <i>Undo</i> to undo the stacked functions and cancel
the switch when you are in <i>Confirm</i> mode.  You can however
use <i>Undo</i> normally while in <i>Switch</i> mode.</p>

<p>A few functions have special behavior when executed during the
switch quantization period.</p>

<ul>
<li><b>Record</b> - forces the next loop to be rerecorded, even if it is not empty</li>
<li><b>Overdub</b> - performs a <ref>Sound Copy</ref> if the next loop is empty</li>
<li><b>Multiply</b> - performs a <ref>Sound Copy</ref> if the next loop is empty</li>
<li><b>Insert</b> - performs a <ref>Time Copy</ref> if the next loop is empty</li>
</ul>

<p>A <ref>Sound Copy</ref> creates an instant copy of the original
loop in the next loop.  A <ref>Time Copy</ref> creates a <i>clear</i>
loop of the same size as the original loop, but does not copy over any
of the audio content.  Both of these concepts are described in more
detail later.</p>

<p>The difference between <i>Overdub</i> and <i>Multiply</i> is what
mode the loop will be left on after the sound copy.  When
<i>Overdub</i> was stacked, the loop will always be left in <i>Overdub</i> 
mode if a sound copy occurred.  If <i>Multiply</i> was stacked the loop will
be left in the mode specified by the <i>Sound Copy Mode</i> preset parameter.</p>

<!-- TODO: Need real Sound Copy and Time Copy functions and events
so we can convert these into something that looks like what it will do -->

</section> <!-- Switch and Confirm Modes -->

<section><title>Empty Loop Action</title>

<p>If you switch to a loop that is empty, the <i>Empty Loop Action</i>
parameter will be used to determine what happens after the switch.  
The possible values for <i>Empty Loop Action</i> are:</p>

<ul>
<li>None</li>
<li>Record</li>
<li>Copy</li>
<li>Copy Timing</li>
</ul>

<p>When set to <i>None</i>,  no automatic action will be performed.
The loop will be left in <i>Reset</i> mode.</p>

<p>When set to <i>Record</i>, the loop will immediately
enter <i>Record</i> mode after the switch. You can record as long as
you like but you must remember to execute the <i>Record</i> function
to end the recording.</p>

<p>When set to <i>Copy</i> a <ref>Sound Copy</ref> will be made
from the original loop into the new loop.</p>

<p>When set to <i>Copy Timing</i> a <ref>Time Copy</ref> will be made
from the original loop into the new loop.</p>

<p><i>Copy Timing</i> and less often <i>Copy Sound</i> are very useful
because they let you creating synchronized loops that are exactly the
same size or an exact multiple of a common factor.  See the
<a href='synchronization.htm#Loop Copy'>Loop Copy</a> section
of the <i>Mobius Synchronization</i> manual for more information
on creating synchronized loops.</p>

<section><title>Time Copy</title>

<p>When <i>Empty Loop Action</i> is set to <i>Copy Timing</i> and you
switch to an empty loop, a new <i>clear</i> loop will be instantly
created that is exactly the same size as the previous loop.  This is
called a <i>Time Copy</i>.  Review the 
<a href='starting.htm#Reset, Empty, Clear, and Silent'>Reset, Empty, Clear, and Silent</a>
section of the <i>Getting Started</i> manual if you are not sure about
the difference between "empty" and "clear".  A <i>clear</i> loop has a
size and it can be played and modified, it just starts out with no
audio content.</p>

<p>In addition to copying the size, time copy will also copy the
number of cycles.</p>

<section><title>Time Copy Mode</title>

<p>When you first switch to a time copied loop, you will be placed in a mode
defined by the <i>Time Copy Mode</i> preset parameter.  The possible
values are:</p>

<ul>
<li><b>Play</b></li>
<li><b>Overdub</b></li>
<li><b>Multiply</b></li>
<li><b>Insert</b></li>
</ul>

<p>The default value is <i>Insert</i>.</p>

<p>When <i>Time Copy Mode</i> is set to <i>Play</i> the copied loop
will simply start playing.  When set to any of the other values, it
behaves as if that function were automatically executed immediately
after the copy. You must then remember to execute that function again
to cancel that mode.  For example, when <i>Time Copy Mode</i> is set
to <i>Insert</i> you will immediately begin inserting into copied
loop.  You must press the button for the <i>Insert</i> function when
you are finished.</p>

<p>The values available here are the same as those available
for <ref>Sound Copy Mode</ref>.  This means you can select <i>Multiply</i>
but this is less useful after a time copy because there is no audio
content to repeat so <i>Multiply</i> behaves almost the same
as <i>Insert</i>.  The main reason to use <i>Multiply</i> here is if
the source loop had several cycles and you wanted to immediately use
"remultiply" to remove some of the cycles from the end.
See <ref id='shortening'>Shortening The Loop</ref> for more information on using
the <i>Multiply</i> function to make the loop smaller.</p>

</section> <!-- Time Copy Mode -->

</section> <!-- Time Copy -->

<section><title>Sound Copy</title>

<p>When <i>Empty Loop Action</i> is set to <i>Copy</i> and you switch
to an empty loop, the current loop will be instantly copied to the
next loop.  This is called a <i>Sound Copy</i>.  From the listener's
perspective, they won't know the copy happened, they will still be
hearing the original loop.</p>

<p>You may now begin changing the copied loop using <i>Overdub</i>,
<i>Multiply</i> or any other function.  When you are finished
modifying the copied loop you can use the same technique to create
another loop, or you may switch back to the original loop.</p>

<section><title>Sound Copy Mode</title>

<p>When you first switch to a copied loop, you will be placed in a
mode defined by the <i>Sound Copy Mode</i> preset parameter.  The
possible values are:</p>

<ul>
<li><b>Play</b></li>
<li><b>Overdub</b></li>
<li><b>Multiply</b></li>
<li><b>Insert</b></li>
</ul>

<p>The default value is <i>Multiply</i>.</p>

<p>When <i>Sound Copy Mode</i> is set to <i>Play</i> the copied loop
will simply start playing.  When set to any of the other values, it
behaves as if that function were automatically executed immediately
after the copy. You must then remember to execute that function again
to cancel that mode.  For example, when <i>Sound Copy Mode</i> is set
to <i>Multiply</i> you will immediately begin multiplying the copied
loop.  You must press the button for the <i>Multiply</i> function when
you are finished multiplying.</p>

<p>Some people find it convenient to assign the <i>Play</i> function
to a button.  <i>Play</i> is like a universal mode canceling function,
if you are in any recording mode (<i>Record</i>, <i>Multiply</i>,
<i>Insert</i> etc.) pressing <i>Play</i> will cancel that mode and return
you to <i>Play</i> mode.  So after you have performed a loop copy you don't
need to think about <i>Sound Copy Mode</i> and execute the corresponding
function to end the mode, just use <i>Play</i> and it will cancel whatever
mode you are in.</p>

</section> <!-- Sound Copy Mode -->

</section> <!-- Sound Copy -->

</section> <!-- Empty Loop Action -->

<section><title>Switch Location</title>

<p>The <i>Switch Location</i> parameter determines where the playback
position will be after you switch to another loop.  The possible values
are:</p>

<ul>
<li><b>Follow</b> - keep the same location you had in the previous loop</li>
<li><b>Restore</b> - restore the location the new loop had the last time it was playing</li>
<li><b>Start</b> - start the new loop from the beginning</li>
<li><b>Random</b> - move to a randomly chosen subcycle</li>
</ul>

<p>When using <i>Follow</i>, if the new loop is smaller than the
current loop the playback position may need to be "wrapped" so that it 
fits within the new loop.  For example if the current loop is 6 seconds
long and you are currently at the start of second 5, then you switch
to a loop that is 3 seconds long, the new loop location will be at
the start of second 2.</p>

<p>When using <i>Restore</i>, if the new loop has never been played the
location will be at the start.  If you are using one of the methods
to perform a sound copy or a timing copy (see <ref>Empty Loop Action</ref>) then
the location will not be restored.</p>

<p><i>Switch Location</i> only applies if the loop is not empty (in
Reset mode).  If the loop is empty then the new location will always
be at frame zero of the empty loop.</p>

</section> <!-- Switch Location -->

<section><title>Switch Duration</title>

<p>The <i>Switch Duration</i> parameter determines how long you will
stay in the new loop after a switch.  This parameter is used by all
switch functions except <i>Sustain Next Loop</i>, <i>Sustain Previous Loop</i>,
<i>Restart</i>, and <i>Restart Once</i>.    The possible values are:</p>

<ul>
<li><b>Permanent</b> - stay in the new loop until it is manually changed</li>
<li><b>Once</b> - play the new loop until the end, then automatically enter <i>Mute</i> mode</li>
<li><b>Once Return</b> - play the new loop until the end, then automatically return to the previous loop</li>
<li><b>Sustain</b> - play the new loop for as long as the function button is held down, then it automatically enter <i>Mute</i> mode</li>
<li><b>Sustain Return</b> - play the new loop for as long as the function button is held down, then return to the previous loop</li>
</ul>

<p>The most common option is <i>Permanent</i>, you remain in the new
loop until you change it with another loop switch function.</p>

<p>The <i>Once</i> option when combined with a <ref>Switch
Location</ref> value of <i>Start</i> makes the loop triggering
functions behave similar to a sampler.  The loop always starts playing
from the beginning, plays once, then stops (enters mute mode).</p>

<p>The <i>Sustain</i> option must be used with a switch function
bound to a 
<a href='starting.htm#Sustainable Trigger'>sustainable trigger</a>. 
If you use a non-sustainable trigger then this will behave the same
as <i>Permanent</i>, you will remain in the new loop but it will not
enter <i>Mute</i> mode automatically.</p>

<p>The <i>Sustain Return</i> option must also be used with a switch function
bound to a 
<a href='starting.htm#Sustainable Trigger'>sustainable trigger</a>. 
If you use a non-sustainable trigger then this will behave the same
as <i>Permanent</i>.</p>

<p>Note that when <i>Switch Duration</i> is set to <i>Sustain
Return</i> the <i>Next Loop</i> function behaves the same as
the <i>Sustain Next Loop</i> function.  <i>Sustain Next Loop</i>,
and <i>Sustain Previous Loop</i> will always return to the original
loop when the sustain ends.  They ignore the <i>Switch Duration</i>
parameter.</p>

<p>The <i>Restart</i> and <i>Restart Once</i> functions ignore
the <i>Switch Duration</i> parameter.  <i>Restart</i> always behaves
as if <i>Switch Duration</i> was set to <i>Permanent</i> and
<i>Restart Once</i> always behaves as if <i>Switch Duration</i>
was set to <i>Once</i>.</p>

</section> <!-- Switch Duration -->

<section><title>Return Location</title>

<p>If you switch to a loop with the <ref>Switch Duration</ref>
parameter set to <i>Once Return</i> or <i>Sustain Return</i> you will
eventually be automatically returned to the original loop unless you
cancel the return.  The <i>Return Location</i> parameter determines
where you will begin playing in the original loop.  The possible
values are the same as the values for the <ref>Switch Location</ref>
parameter.</p>

<ul>
<li><b>Follow</b> - keep the same location you have in the current loop</li>
<li><b>Restore</b> - restore the location the original loop had the last time it was playing</li>
<li><b>Start</b> - start the original loop from the beginning</li>
<li><b>Random</b> - move to a randomly chosen subcycle</li>
</ul>

<p>When using <i>Follow</i>, if the original loop is smaller than the
current loop the playback position may need to be "wrapped" so that it
fits within the new loop.  For example if the current loop is 6
seconds long and you are currently at the start of second 5, then you
return to a loop that is 3 seconds long, the new loop location will be
at the start of second 2.</p>

</section>

<section><title>Switch State Transfer</title>

<p>When you execute any of the loop switch functions, you can choose
to have some of the current loop modes carried over to the next loop.
This is controlled with a set of "transfer mode" preset parameters
found under the <i>Loop Switch</i> tab.</p>

<section><title>Record Transfer</title>

<p>The <i>Record Transfer</i> parameter determines whether
the <i>Record</i> major mode will be carried over from the current
loop to the next loop.  It has these possible values.</p>

<ul>
<li>Off - Record is not transferred</li>
<li>Follow - Record is transferred</li>
</ul>

<p>When this parameter is set to <i>Follow</i>, if the current loop is
in <i>Record</i> mode, after the switch the next loop will also
automatically enter <i>Record</i> mode.  Note that this will happen
whether or not the next loop is empty.  This option is useful if you
want to record a set of loops all at once without stopping.  Start
by executing the <i>Record</i> function to record the first loop.
Then execute the <i>Next Loop</i> function to end the current recoding
and immediately begin recording the next loop.</p>

<p>When this parameter is set to <i>Off</i> and the current 
loop is in <i>Record</i> mode, executing a switch function will finish
the recording of the current loop then switch to the next loop.
If the next loop is not empty it will simply start playing.  If the next
loop is empty the <ref>Empty Loop Action</ref> parameter controls
what will happen.</p>

</section> <!-- Record Transfer -->

<section><title>Overdub Transfer</title>

<p>The <i>Overdub Transfer</i> parameter determines whether
the <i>Overdub</i> minor mode will be carried over from the current
loop to the next loop.  It has these possible values.</p>

<ul>
<li>Off - Overdub will be forced off in the next loop</li>
<li>Follow - Overdub will be carried over from the current loop to the next loop</li>
<li>Restore - Overdub will be restored to the state it had the last time the next loop was active</li>
</ul>

<p>The default value is <i>Off</i>.  If you like to leave overdub
mode on all the time and control overdubbing by muting your instrument
you may want to set this to <i>Follow</i> so you don't have to 
reactivate overdub every time you switch loops.</p>

<p>Setting this to <i>Restore</i> is relatively unusual because you
usually care more about what the overdub state is now, not what it
was in the past.</p>

</section> <!-- Overdub Transfer -->

<section><title>Reverse Transfer</title>

<p>The <i>Reverse Transfer</i> parameter determines whether
the <i>Reverse</i> minor will be carried over from the current
loop to the next loop.  It has these possible values.</p>

<ul>
<li>Off - Reverse will be forced off in the next loop</li>
<li>Follow - Reverse will be carried over from the current loop to the next loop</li>
<li>Restore - Reverse will be restored to the state it had the last time the next loop was active</li>
</ul>

<p>The default value is <i>Off</i>.  If you think of reverse
as a "global" option that should apply to all loops in a track then
set this parameter to <i>Follow</i>.</p>

<p>Setting this to <i>Restore</i> may be interesting if you want to have
some loops that always play forward and some that always play 
in reverse.</p>

</section> <!-- Reverse Transfer -->

<section><title>Speed Transfer</title>

<p>The <i>Speed Transfer</i> parameter determines whether the various speed related
minor modes will be carried over from the current loop to the
next loop.  This applies to shift applied by all of the <i>Speed</i> functions
as the speed controls.  It has these possible values.</p>

<ul>
<li>Off - Speed shift will be off in the next loop</li>
<li>Follow - Speed shift will be carried over from the current loop to the next loop</li>
<li>Restore - Speed shift will be restored to the state it had the last time the next loop was active</li>
</ul>

<p>The default value is <i>Off</i>.  If you think of speed shift
as a "global" option that should apply to all loops in a track then
set this parameter to <i>Follow</i>.</p>

<p>Setting this to <i>Restore</i> may be interesting if you want to have
loops that always play at different speeds.</p>

</section> <!-- Speed Transfer -->

<section><title>Pitch Transfer</title>

<p>The <i>Pitch Transfer</i> parameter determines whether the various <i>Pitch</i> related
minor modes will be carried over from the current loop to the
next loop.  It has these possible values.</p>

<ul>
<li>Off - Pitch shift will be off in the next loop</li>
<li>Follow - Pitch shift will be carried over from the current loop to the next loop</li>
<li>Restore - Pitch shift will be restored to the state it had the last time the next loop was active</li>
</ul>

<p>The default value is <i>Off</i>.  If you think of pitch shift as a
"global" option that should apply to all loops in a track then set
this parameter to <i>Follow</i>.</p>

<p>Setting this to <i>Restore</i> may be interesting if you want to
have loops that always play with different amounts of pitch shift.</p>

</section> <!-- Pitch Transfer -->

</section> <!-- Switch State Transfer -->

<section><title>Switch Velocity Sensitive</title>

<p>The <i>Switch Velocity Sensitive</i> parameter can be used to
automatically adjust the track output level during a loop switch.
This can only be used if the loop switch function is bound to a
MIDI <i>Note</i> message that can carry velocity information.  When
this parameter is checked, the output level of the track will be set
to the velocity value of the MIDI note that triggered the loop switch
function.  If a loop switch function is not bound to a MIDI <i>Note</i>
message, then this parameter will be ignored.</p>

<p>This is most often used with the 8 numbered <i>Loop X</i> functions
bound to adjacent keys on a MIDI keyboard, or to velocity sensitive
pads on a control surface.  Once loops have been recorded you can then
"play" the loops by triggering them from the MIDI device making them
softer of louder depending on how hard you hit the key/pad.  If you
also set the <ref>Switch Location</ref> parameter to <i>Start</i> and the
<ref>Switch Duration</ref> to <i>Once</i> it will behave like a
simple velocity sensitive sample player.</p>

</section> <!-- Switch Velocity Sensitive -->

<section><title>Restart and Restart Once</title>

<p>The <i>Restart</i> and <i>Restart Once</i> functions are
considered to be loop switch functions but they are unusual because
they do not change the loop.  They always restart the current loop
from the beginning and stay in the current loop.</p>

<p>They will obey the <ref>Switch Quantize</ref> parameter so that you
can stack functions to be executed after the restart.  But they
ignore the <ref>Switch Location</ref> and <ref>Switch Duration</ref>
parameters.</p>

<p>Since the loop does not change all of the 
<ref>Switch State Transfer</ref> parameters are also ignored.</p>

</section> <!-- Restart and Restart Once -->

</section> <!-- Loop Switching -->

<!-- ======================================================================

  Jumping

  Move, Slip, SlipForward, SlipBackward
  SlipMode, SlipTime

====================================================================== -->

<section><title id='jumping'>Changing Playback Position</title>
</section> <!-- Changing Playback Position -->

<!-- ======================================================================

  Start Point

  Start Point
  QuantMIDiStartPoint

====================================================================== -->

<section><title id='StartPoint'>Changing The Start Point</title>
</section> <!-- Changing The Start Point -->

<!-- ======================================================================

  Loop Windowing

====================================================================== -->

<section><title id='LoopWindowing'>Loop Windowing</title>

<p>Loop Windowing is a mode that allows you to move backwards and forwards
within the loop history and play sections of the loop at that time.  It is
somewhat like <i>Undo</i> and <i>Redo</i> but with more control over the
position and size of the new loop.  Think of
all the loop layers as being connected in a single length of recording tape, 
then being able to instantly rewind to any position within that tape and
play a section of any length.  This "window" into the loop history can then
be adjusted by sliding it forward and backward, and the starting and ending
edges of the window can be adjusted independently to fine tune the size
of the window.  Windowing can be unpredictable and well suited for "glitch" 
looping, but with careful use of quantization and the windowing parameters you
can also create interesting rhythms that maintain a consistent tempo.</p>

<p>There are six functions that can be bound to phyiscal controllers to
change the window position and size.</p>

<ul>
<li>Window Backward</li>
<li>Window Forward</li>
<li>Window Start Backward</li>
<li>Window Start Forward</li>
<li>Window End Backward</li>
<li>Window End Forward</li>
</ul>

<p>In addition there are two functions that may be used in scripts for
even more control over the window.</p>

<ul>
<li>WindowMove</li>
<li>WindowResize</li>
</ul>

<p>The following preset parameters control how the window is moved
and sized.</p>

<ul>
<li>Window Slide Unit</li>
<li>Window Slide Amount</li>
<li>Window Edge Unit</li>
<li>Window Edge Amount</li>
</ul>

<p>Though it is not required, loop windowing is usually performed after
doing an "unrounded multiply" or a "remultiply" to cut the loop down
to a shorter length.  Unrounded multiply is the <i>Multiply</i>
function followed by the <i>Record</i> function which can cut out a 
section of any size.  Remultiply is <i>Multiply</i> followed by another
<i>Multiply</i> within a loop that has more than one cycle to cut
out a section that is exactly some number of cycles.  Other functions that
reduce the size of the loop include <i>Divide</i>, <i>Trim Start</i>,
and <i>Trim End</i>.</p>

<p>Once the loop length has been reduced, you then start by using the
<i>Window Backward</i> function one or more times.  With the default
parameters you will move backward an amount equal to the current loop length.
If you have not changed the length of the loop, the effect will be
similar to using <i>Undo</i>, you simply move backward in the loop history
one layer at a time.  But if you have shortened the loop, you will be playing
subsections of layers, or sections from <i>different</i> layers as you move
the window.  After you have moved the window backward, you can use the 
<i>Loop Window Forward</i> function to move it in the other direction,
up until you return to the most recent loop.  The effect is similar to
<i>Redo</i> but you are not limited by layer boundaries.</p>

<p>The amount of time the window is moved forward or backward is
controlled by the <i>Window Slide Unit</i> and <i>Window Slide Amount</i>
preset parameters.  <i>Window Slide Amount</i> is a positive number and
<i>Window Slide Unit</i> may have the following values:</p>

<ul>
<li>Loop</li>
<li>Cycle</li>
<li>Subcycle</li>
<li>Millisecond</li>
<li>Frame</li>
</ul>

<p>The default value is <i>Loop</i> which means you slide the
window by the current length of the loop.  Setting this to <i>Cycle</i>
or more often <i>Subcycle</i> lets you slide the loop by smaller amounts
but still maintaining an exact mathemetical relationship to the
original loop.  The <i>Millisecond</i> and <i>Frame</i> units give
you more control over the length of the slide, but since the values
may not be musically related to the original loop these are best
used for unpredictable "glitch" looping.</p>

<p>The <i>Window Slide Amount</i> parameter is usually left at 1
for <i>Loop</i>, <i>Cycle</i>, and <i>Subcycle</i> units.  This value
is a unit multiplier so with a unit of <i>Subcycle</i>
and an amount of <i>4</i> you will slide forward or backward
by 4 subcycles.</p>

<p>For the <i>Millisecond</i> unit, the <i>Window Slide Amount</i>
is the a number of milliseconds, so <i>1000</i> would slide the window 
forward and backward by 1 second.  For the <i>Frame</i> unit, the
slide amount is the number of frames, which are pairs of 
stereo samples.  Determining the length of the slide in frames 
depends on your sample rate selection in the <i>Audio Devices</i> 
window.  With the default sample rate, entering <i>44100</i> as
the amount would result in a slide of 1 second.</p>

<p>Sometimes after sliding a window, you may want to add or remove a little
from the start or end of the new loop.  The <i>Window Start Backward</i>
and <i>Window Start Forward</i> funtions move the start of the
window without changing the end, and the <i>Window End Backward</i>
and <i>Window End Forward</i> move the end of the window
without changing the start.  The amount the window is resized is
controlled by the <i>Window Edge Unit</i> and <i>Window Edge Amount</i>
preset parameters.  <i>Window Edge Amount</i> is a positive number
and <i>Window Edge Unit</i> has the same values as 
<i>Window Slide Unit</i>.</p>

<p>The default value for <i>Window Edge Unit</i> is <i>Subcycle</i> which
is useful for creating loops that maintain remain at the original tempo.
<i>Millisecond</i> or <i>Frame</i> can be used to fine tune the window edges.</p>
 
<p>You can use the windowing functions in any combination, for example sliding
the window backward, changing the starting and ending edges, then sliding
the modified window forward.  When you reach the beginning or ending of
the loop history, it may not be possible to change the loop by the 
selected unit.  For example if you are at loop frame 10,000 and a subcycle
is 20,000 frames long and you then use the <i>Widow Backward</i> function
with a <i>Window Slide Unit</i> of <i>Subcycle</i> you cannot move backward
20,000 frames.  The slide will be limited to what is available, 10,000 frames.
This may mean that when you reach either end of the loop history, the window
position may shift so that when you slide in the opposite direction you
won't be playing exactly the same windows that were playing when you
were sliding toward the history edge.</p>

<section><title>Window Mode</title>

<p>Once you use any of the loop windowing functions, a new
layer is created called the "window layer".  Any modification you have
made to the current layer are lost.    For example, if you are in the
middle of the loop and <i>Overdub</i> mode was on, the last overdub
will be discarded and will not be part of the loop history.  The window layer
differs from other layers in that it can be changed by the windowing
functions without creating a new layer for each change.  You could
slide the window forward and backward 100 times, but there will still be
only one window layer.</p>

<p>While a window layer is active, you are in the <i>Window</i> minor
mode.  The word "Window" will appear in the <i>Minor Modes</i> display
component if you have it enabled.  The <i>Loop Window</i> display 
component will also appear to show you a graphical representation
of the loop history and the position of the window within it.  If
you are upgrading from an earlier release, the <i>Loop Window</i>
component will not be enabled, you will need to use the 
<i>Display Components</i> dialog and add it to the <i>Components</i>
list at the top.</p>

<p>If you decide you no longer want the window layer, use <i>Undo</i>
to cancel <i>Window</i> mode and return you to the previous normal
layer.  If you have selected a window that you would like to keep, 
you may simply keep playing the window or begin modifying it with
other functions such as <i>Overdub</i> and <i>Multiply</i>.  If you
make changes to the window layer and you let it play to the end without
using any of the windowing functions, then the window layer is added
to the loop history and you exit <i>Window</i> mode.</p>

<p>It is important to understand the relationship between <i>Window</i>
mode and the <i>Feedback</i> control.  If you have reduced <i>Feedback</i>
you are making a change to the layer being played.  You are recording a new
layer containing the layer being played at a reduced level.  If you
are in <i>Window</i> mode with <i>Feedback</i> lowered and you let the window
layer play to the end, the window layer will be added to the history
and you will exit <i>Window</i> mode.  This can make it difficult to 
position the window if the window is short.  The window will quickly
play to the end and cancel <i>Window</i> mode before you have a chance
to slide the window to the desired location.  For this reason it
is recommended that you do not leave <i>Feedback</i> lowered or
be in <i>Overdub</i> mode when you use windowing functions.</p>

</section>

<section><title>Scripting Windows</title>

<p>The loop window may be controlled from scripts using the
<i>WindowMove</i> and <i>WindowResize</i> functions.  These functions
will not appear in the binding windows, they are only available 
in scripts.  The location and size of the window is specified 
with function arguments.  This is described in more detail
in the <a href='scripts.htm#LoopWindowing'>Loop Windowing</a> section
of the <i>Mobius Scripting</i> manual.</p>

</section>

</section> <!-- Loop Windowing -->

<!-- ======================================================================

  Long Press

  GP: LongPressTime
  Record, ...find all the others...

====================================================================== -->

<section><title>Long Presses</title>
</section> <!-- Long Presses -->

<!-- ======================================================================

  Track Management

  NextTrack, PrevTrack, TrackX
  TrackCopy, TrackCopyTiming
  FocusLock
  TrackGroup
  EmptyTrackMode
  LoopCount
  GP: TrackGroups

====================================================================== -->

<section><title>Managing Tracks</title>
</section> <!-- Managing Tracks -->

<!-- ======================================================================

  Bounce

  Bounce
  BounceQuantize

====================================================================== -->

<section><title>Bounce Recording</title>

<p>The <i>Bounce</i> function allows you to capture the
output of several tracks, mix them together, and copy the result into
an empty track.  This is similar to the <i>bounce down</i> mixing
technique used with a multi track recorder.</p>

<p>When the Bounce Record function is first called, it begins
capturing the output of any track that is currently playing.  The
track output is mixed together "post fader" so the Output Level
control of each track may be used to control the track mix
in the recording.</p>

<p>When Bounce Record is called a second time, the captured and mixed
track output is copied to the first empty track (from the left).  The
source tracks are then immediately muted, and the new track immediately
begins playing.  This new track contains a single loop with the
captured output from the other tracks.  This loop can then be
manipulated as usual.</p>

<p>Any number of bounce recordings can be made, but you must have at
least one empty track.  If there are no empty tracks when the
second Bounce Record is called, the recording is thrown away.</p>

<p>Note that bounce recording is a special kind of "global mode" that
is not related to any particular track or loop.  While you are bounce
recording, you can be manipulating tracks and loops in any way,
including recording new loops, multiplying, overdubbing, triggering,
and speed shifting.  Mobius is recording the entire process.</p>

<p>Bounce recording can be especially useful with the Restart, Speed
Shift and Pitch Shift functions.  Once a loop is created, you can
play a chord progression using Speed Shift or Pitch Shift, record the
result of that performance, and bounce this into a new track to serve
as a background loop.</p>

<p>The timing of the bounce recording may be controlled with the
<i>Bounce Quantize</i> parameter.  Bounce quantization is not affected
by the <i>Quantize</i> parameter that is used with other functions.
This is because bounce quantization is almost always set to <i>Loop</i>
or <i>Cycle</i>, but you may not wish to use this same quantization
for the functions that build the loop.</p>

</section> <!-- Bounce Recording -->

<!-- ======================================================================

  Performance Recording

  StartCapture, StopCapture, SaveCapture

====================================================================== -->

<section><title id='capture'>Capturing a Performance</title>
</section> <!-- Recording a Performance -->

<!-- ======================================================================

  Sending MIDI Messages

  MIDIOut, MIDIStart, MIDIStop
  Reference sync manual for realtime messages

====================================================================== -->

<section><title id='sendingMidi'>Sending MIDI Messages</title>
</section> <!-- Sending MIDI -->

<!-- ======================================================================

  MIDI Loopback

====================================================================== -->

<section><title>Host Control With MIDI Loopback Devices</title>
</section> <!-- MIDI Loopback -->


</document>

